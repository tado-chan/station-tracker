{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { ViewContainerRef, Component, Attribute, Optional, SkipSelf, ViewChild, ChangeDetectionStrategy, Directive, ContentChild, ContentChildren, inject, Injector, EnvironmentInjector, Injectable, makeEnvironmentProviders, APP_INITIALIZER, forwardRef, HostListener } from '@angular/core';\nimport * as i2$1 from '@ionic/angular/common';\nimport { IonRouterOutlet as IonRouterOutlet$1, ProxyCmp as ProxyCmp$1, IonBackButton as IonBackButton$1, IonModal as IonModal$1, IonPopover as IonPopover$1, RouterLinkDelegateDirective, RouterLinkWithHrefDelegateDirective, IonTabs as IonTabs$1, OverlayBaseController, AngularDelegate, ConfigToken, provideComponentInputBinding, MenuController as MenuController$1, IonNav as IonNav$1, ValueAccessor, setIonicClasses } from '@ionic/angular/common';\nconst _c0 = [\"outletContent\"];\nconst _c1 = [\"*\"];\nfunction IonModal_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵelementContainer(1, 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template);\n  }\n}\nfunction IonPopover_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 1);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.template);\n  }\n}\nconst _c2 = [\"outlet\"];\nconst _c3 = [[[\"\", \"slot\", \"top\"]], \"*\", [[\"ion-tab\"]]];\nconst _c4 = [\"[slot=top]\", \"*\", \"ion-tab\"];\nfunction IonTabs_ion_router_outlet_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ion-router-outlet\", 5, 1);\n    i0.ɵɵlistener(\"stackWillChange\", function IonTabs_ion_router_outlet_3_Template_ion_router_outlet_stackWillChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onStackWillChange($event));\n    })(\"stackDidChange\", function IonTabs_ion_router_outlet_3_Template_ion_router_outlet_stackDidChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.onStackDidChange($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction IonTabs_ng_content_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngIf\", \"tabs.length > 0\"]);\n  }\n}\nexport { Config, DomController, IonModalToken, IonicRouteStrategy, NavController, NavParams, Platform } from '@ionic/angular/common';\nimport { defineCustomElement as defineCustomElement$2 } from '@ionic/core/components/ion-back-button.js';\nimport { defineCustomElement as defineCustomElement$1 } from '@ionic/core/components/ion-router-outlet.js';\nimport * as i1 from '@angular/common';\nimport { CommonModule, NgIf, DOCUMENT } from '@angular/common';\nimport * as i2 from '@angular/router';\nimport { defineCustomElement as defineCustomElement$3 } from '@ionic/core/components/ion-modal.js';\nimport { defineCustomElement as defineCustomElement$4 } from '@ionic/core/components/ion-popover.js';\nimport { fromEvent } from 'rxjs';\nimport { defineCustomElement as defineCustomElement$5 } from '@ionic/core/components/ion-accordion.js';\nimport { defineCustomElement as defineCustomElement$6 } from '@ionic/core/components/ion-accordion-group.js';\nimport { defineCustomElement as defineCustomElement$7 } from '@ionic/core/components/ion-action-sheet.js';\nimport { defineCustomElement as defineCustomElement$8 } from '@ionic/core/components/ion-alert.js';\nimport { defineCustomElement as defineCustomElement$9 } from '@ionic/core/components/ion-app.js';\nimport { defineCustomElement as defineCustomElement$a } from '@ionic/core/components/ion-avatar.js';\nimport { defineCustomElement as defineCustomElement$b } from '@ionic/core/components/ion-backdrop.js';\nimport { defineCustomElement as defineCustomElement$c } from '@ionic/core/components/ion-badge.js';\nimport { defineCustomElement as defineCustomElement$d } from '@ionic/core/components/ion-breadcrumb.js';\nimport { defineCustomElement as defineCustomElement$e } from '@ionic/core/components/ion-breadcrumbs.js';\nimport { defineCustomElement as defineCustomElement$f } from '@ionic/core/components/ion-button.js';\nimport { defineCustomElement as defineCustomElement$g } from '@ionic/core/components/ion-buttons.js';\nimport { defineCustomElement as defineCustomElement$h } from '@ionic/core/components/ion-card.js';\nimport { defineCustomElement as defineCustomElement$i } from '@ionic/core/components/ion-card-content.js';\nimport { defineCustomElement as defineCustomElement$j } from '@ionic/core/components/ion-card-header.js';\nimport { defineCustomElement as defineCustomElement$k } from '@ionic/core/components/ion-card-subtitle.js';\nimport { defineCustomElement as defineCustomElement$l } from '@ionic/core/components/ion-card-title.js';\nimport { defineCustomElement as defineCustomElement$m } from '@ionic/core/components/ion-chip.js';\nimport { defineCustomElement as defineCustomElement$n } from '@ionic/core/components/ion-col.js';\nimport { defineCustomElement as defineCustomElement$o } from '@ionic/core/components/ion-content.js';\nimport { defineCustomElement as defineCustomElement$p } from '@ionic/core/components/ion-datetime-button.js';\nimport { defineCustomElement as defineCustomElement$q } from '@ionic/core/components/ion-fab.js';\nimport { defineCustomElement as defineCustomElement$r } from '@ionic/core/components/ion-fab-button.js';\nimport { defineCustomElement as defineCustomElement$s } from '@ionic/core/components/ion-fab-list.js';\nimport { defineCustomElement as defineCustomElement$t } from '@ionic/core/components/ion-footer.js';\nimport { defineCustomElement as defineCustomElement$u } from '@ionic/core/components/ion-grid.js';\nimport { defineCustomElement as defineCustomElement$v } from '@ionic/core/components/ion-header.js';\nimport { defineCustomElement as defineCustomElement$w } from '@ionic/core/components/ion-img.js';\nimport { defineCustomElement as defineCustomElement$x } from '@ionic/core/components/ion-infinite-scroll.js';\nimport { defineCustomElement as defineCustomElement$y } from '@ionic/core/components/ion-infinite-scroll-content.js';\nimport { defineCustomElement as defineCustomElement$z } from '@ionic/core/components/ion-input-password-toggle.js';\nimport { defineCustomElement as defineCustomElement$A } from '@ionic/core/components/ion-item.js';\nimport { defineCustomElement as defineCustomElement$B } from '@ionic/core/components/ion-item-divider.js';\nimport { defineCustomElement as defineCustomElement$C } from '@ionic/core/components/ion-item-group.js';\nimport { defineCustomElement as defineCustomElement$D } from '@ionic/core/components/ion-item-option.js';\nimport { defineCustomElement as defineCustomElement$E } from '@ionic/core/components/ion-item-options.js';\nimport { defineCustomElement as defineCustomElement$F } from '@ionic/core/components/ion-item-sliding.js';\nimport { defineCustomElement as defineCustomElement$G } from '@ionic/core/components/ion-label.js';\nimport { defineCustomElement as defineCustomElement$H } from '@ionic/core/components/ion-list.js';\nimport { defineCustomElement as defineCustomElement$I } from '@ionic/core/components/ion-list-header.js';\nimport { defineCustomElement as defineCustomElement$J } from '@ionic/core/components/ion-loading.js';\nimport { defineCustomElement as defineCustomElement$K } from '@ionic/core/components/ion-menu.js';\nimport { defineCustomElement as defineCustomElement$L } from '@ionic/core/components/ion-menu-button.js';\nimport { defineCustomElement as defineCustomElement$M } from '@ionic/core/components/ion-menu-toggle.js';\nimport { defineCustomElement as defineCustomElement$N } from '@ionic/core/components/ion-nav-link.js';\nimport { defineCustomElement as defineCustomElement$O } from '@ionic/core/components/ion-note.js';\nimport { defineCustomElement as defineCustomElement$P } from '@ionic/core/components/ion-picker.js';\nimport { defineCustomElement as defineCustomElement$Q } from '@ionic/core/components/ion-picker-column.js';\nimport { defineCustomElement as defineCustomElement$R } from '@ionic/core/components/ion-picker-column-option.js';\nimport { defineCustomElement as defineCustomElement$S } from '@ionic/core/components/ion-picker-legacy.js';\nimport { defineCustomElement as defineCustomElement$T } from '@ionic/core/components/ion-progress-bar.js';\nimport { defineCustomElement as defineCustomElement$U } from '@ionic/core/components/ion-radio.js';\nimport { defineCustomElement as defineCustomElement$V } from '@ionic/core/components/ion-refresher.js';\nimport { defineCustomElement as defineCustomElement$W } from '@ionic/core/components/ion-refresher-content.js';\nimport { defineCustomElement as defineCustomElement$X } from '@ionic/core/components/ion-reorder.js';\nimport { defineCustomElement as defineCustomElement$Y } from '@ionic/core/components/ion-reorder-group.js';\nimport { defineCustomElement as defineCustomElement$Z } from '@ionic/core/components/ion-ripple-effect.js';\nimport { defineCustomElement as defineCustomElement$_ } from '@ionic/core/components/ion-row.js';\nimport { defineCustomElement as defineCustomElement$$ } from '@ionic/core/components/ion-segment-button.js';\nimport { defineCustomElement as defineCustomElement$10 } from '@ionic/core/components/ion-segment-content.js';\nimport { defineCustomElement as defineCustomElement$11 } from '@ionic/core/components/ion-segment-view.js';\nimport { defineCustomElement as defineCustomElement$12 } from '@ionic/core/components/ion-select-modal.js';\nimport { defineCustomElement as defineCustomElement$13 } from '@ionic/core/components/ion-select-option.js';\nimport { defineCustomElement as defineCustomElement$14 } from '@ionic/core/components/ion-skeleton-text.js';\nimport { defineCustomElement as defineCustomElement$15 } from '@ionic/core/components/ion-spinner.js';\nimport { defineCustomElement as defineCustomElement$16 } from '@ionic/core/components/ion-split-pane.js';\nimport { defineCustomElement as defineCustomElement$17 } from '@ionic/core/components/ion-tab.js';\nimport { defineCustomElement as defineCustomElement$18 } from '@ionic/core/components/ion-tab-bar.js';\nimport { defineCustomElement as defineCustomElement$19 } from '@ionic/core/components/ion-tab-button.js';\nimport { defineCustomElement as defineCustomElement$1a } from '@ionic/core/components/ion-text.js';\nimport { defineCustomElement as defineCustomElement$1b } from '@ionic/core/components/ion-thumbnail.js';\nimport { defineCustomElement as defineCustomElement$1c } from '@ionic/core/components/ion-title.js';\nimport { defineCustomElement as defineCustomElement$1d } from '@ionic/core/components/ion-toast.js';\nimport { defineCustomElement as defineCustomElement$1e } from '@ionic/core/components/ion-toolbar.js';\nimport { modalController, popoverController, initialize, actionSheetController, alertController, createAnimation, getTimeGivenProgression, createGesture, loadingController, menuController, pickerController, toastController } from '@ionic/core/components';\nexport { IonicSafeString, IonicSlides, createAnimation, createGesture, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation } from '@ionic/core/components';\nimport { defineCustomElement as defineCustomElement$1f } from '@ionic/core/components/ion-nav.js';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { defineCustomElement as defineCustomElement$1g } from '@ionic/core/components/ion-checkbox.js';\nimport { defineCustomElement as defineCustomElement$1h } from '@ionic/core/components/ion-datetime.js';\nimport { defineCustomElement as defineCustomElement$1i } from 'ionicons/components/ion-icon.js';\nimport { defineCustomElement as defineCustomElement$1j } from '@ionic/core/components/ion-input.js';\nimport { defineCustomElement as defineCustomElement$1k } from '@ionic/core/components/ion-input-otp.js';\nimport { defineCustomElement as defineCustomElement$1l } from '@ionic/core/components/ion-radio-group.js';\nimport { defineCustomElement as defineCustomElement$1m } from '@ionic/core/components/ion-range.js';\nimport { defineCustomElement as defineCustomElement$1n } from '@ionic/core/components/ion-searchbar.js';\nimport { defineCustomElement as defineCustomElement$1o } from '@ionic/core/components/ion-segment.js';\nimport { defineCustomElement as defineCustomElement$1p } from '@ionic/core/components/ion-select.js';\nimport { defineCustomElement as defineCustomElement$1q } from '@ionic/core/components/ion-textarea.js';\nimport { defineCustomElement as defineCustomElement$1r } from '@ionic/core/components/ion-toggle.js';\nlet IonRouterOutlet = /*#__PURE__*/(() => {\n  let IonRouterOutlet = class IonRouterOutlet extends IonRouterOutlet$1 {\n    parentOutlet;\n    /**\n     * `static: true` must be set so the query results are resolved\n     * before change detection runs. Otherwise, the view container\n     * ref will be ion-router-outlet instead of ng-container, and\n     * the first view will be added as a sibling of ion-router-outlet\n     * instead of a child.\n     */\n    outletContent;\n    /**\n     * We need to pass in the correct instance of IonRouterOutlet\n     * otherwise parentOutlet will be null in a nested outlet context.\n     * This results in APIs such as NavController.pop not working\n     * in nested outlets because the parent outlet cannot be found.\n     */\n    constructor(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n      super(name, tabs, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet);\n      this.parentOutlet = parentOutlet;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRouterOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRouterOutlet)(i0.ɵɵinjectAttribute('name'), i0.ɵɵinjectAttribute('tabs'), i0.ɵɵdirectiveInject(i1.Location), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i2.Router), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.ActivatedRoute), i0.ɵɵdirectiveInject(IonRouterOutlet, 12));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRouterOutlet,\n      selectors: [[\"ion-router-outlet\"]],\n      viewQuery: function IonRouterOutlet_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7, ViewContainerRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.outletContent = _t.first);\n        }\n      },\n      features: [i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 3,\n      vars: 0,\n      consts: [[\"outletContent\", \"\"]],\n      template: function IonRouterOutlet_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵdomElementContainerStart(0, null, 0);\n          i0.ɵɵprojection(2);\n          i0.ɵɵdomElementContainerEnd();\n        }\n      },\n      encapsulation: 2\n    });\n  };\n  IonRouterOutlet = __decorate([ProxyCmp$1({\n    defineCustomElementFn: defineCustomElement$1\n  })], IonRouterOutlet);\n  return IonRouterOutlet;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonBackButton = /*#__PURE__*/(() => {\n  let IonBackButton = class IonBackButton extends IonBackButton$1 {\n    constructor(routerOutlet, navCtrl, config, r, z, c) {\n      super(routerOutlet, navCtrl, config, r, z, c);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonBackButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonBackButton)(i0.ɵɵdirectiveInject(IonRouterOutlet, 8), i0.ɵɵdirectiveInject(i2$1.NavController), i0.ɵɵdirectiveInject(i2$1.Config), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonBackButton,\n      selectors: [[\"ion-back-button\"]],\n      features: [i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonBackButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonBackButton = __decorate([ProxyCmp$1({\n    defineCustomElementFn: defineCustomElement$2\n  })], IonBackButton);\n  return IonBackButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonModal = /*#__PURE__*/(() => {\n  let IonModal = class IonModal extends IonModal$1 {\n    /** @nocollapse */static ɵfac = /* @__PURE__ */(() => {\n      let ɵIonModal_BaseFactory;\n      return function IonModal_Factory(__ngFactoryType__) {\n        return (ɵIonModal_BaseFactory || (ɵIonModal_BaseFactory = i0.ɵɵgetInheritedFactory(IonModal)))(__ngFactoryType__ || IonModal);\n      };\n    })();\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonModal,\n      selectors: [[\"ion-modal\"]],\n      features: [i0.ɵɵInheritDefinitionFeature],\n      decls: 1,\n      vars: 1,\n      consts: [[\"class\", \"ion-delegate-host ion-page\", 4, \"ngIf\"], [1, \"ion-delegate-host\", \"ion-page\"], [3, \"ngTemplateOutlet\"]],\n      template: function IonModal_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, IonModal_div_0_Template, 2, 1, \"div\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngIf\", ctx.isCmpOpen || ctx.keepContentsMounted);\n        }\n      },\n      dependencies: [CommonModule, i1.NgIf, i1.NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonModal = __decorate([ProxyCmp$1({\n    defineCustomElementFn: defineCustomElement$3\n  })], IonModal);\n  return IonModal;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonPopover = /*#__PURE__*/(() => {\n  let IonPopover = class IonPopover extends IonPopover$1 {\n    /** @nocollapse */static ɵfac = /* @__PURE__ */(() => {\n      let ɵIonPopover_BaseFactory;\n      return function IonPopover_Factory(__ngFactoryType__) {\n        return (ɵIonPopover_BaseFactory || (ɵIonPopover_BaseFactory = i0.ɵɵgetInheritedFactory(IonPopover)))(__ngFactoryType__ || IonPopover);\n      };\n    })();\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonPopover,\n      selectors: [[\"ion-popover\"]],\n      features: [i0.ɵɵInheritDefinitionFeature],\n      decls: 1,\n      vars: 1,\n      consts: [[3, \"ngTemplateOutlet\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\"]],\n      template: function IonPopover_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, IonPopover_ng_container_0_Template, 1, 1, \"ng-container\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngIf\", ctx.isCmpOpen || ctx.keepContentsMounted);\n        }\n      },\n      dependencies: [CommonModule, i1.NgIf, i1.NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonPopover = __decorate([ProxyCmp$1({\n    defineCustomElementFn: defineCustomElement$4\n  })], IonPopover);\n  return IonPopover;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet IonRouterLink = /*#__PURE__*/(() => {\n  class IonRouterLink extends RouterLinkDelegateDirective {\n    /** @nocollapse */static ɵfac = /* @__PURE__ */(() => {\n      let ɵIonRouterLink_BaseFactory;\n      return function IonRouterLink_Factory(__ngFactoryType__) {\n        return (ɵIonRouterLink_BaseFactory || (ɵIonRouterLink_BaseFactory = i0.ɵɵgetInheritedFactory(IonRouterLink)))(__ngFactoryType__ || IonRouterLink);\n      };\n    })();\n    /** @nocollapse */\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: IonRouterLink,\n      selectors: [[\"\", \"routerLink\", \"\", 5, \"a\", 5, \"area\"]],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return IonRouterLink;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nlet IonRouterLinkWithHref = /*#__PURE__*/(() => {\n  class IonRouterLinkWithHref extends RouterLinkWithHrefDelegateDirective {\n    /** @nocollapse */static ɵfac = /* @__PURE__ */(() => {\n      let ɵIonRouterLinkWithHref_BaseFactory;\n      return function IonRouterLinkWithHref_Factory(__ngFactoryType__) {\n        return (ɵIonRouterLinkWithHref_BaseFactory || (ɵIonRouterLinkWithHref_BaseFactory = i0.ɵɵgetInheritedFactory(IonRouterLinkWithHref)))(__ngFactoryType__ || IonRouterLinkWithHref);\n      };\n    })();\n    /** @nocollapse */\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: IonRouterLinkWithHref,\n      selectors: [[\"a\", \"routerLink\", \"\"], [\"area\", \"routerLink\", \"\"]],\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return IonRouterLinkWithHref;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable */\n/* tslint:disable */\nconst proxyInputs = (Cmp, inputs) => {\n  const Prototype = Cmp.prototype;\n  inputs.forEach(item => {\n    Object.defineProperty(Prototype, item, {\n      get() {\n        return this.el[item];\n      },\n      set(val) {\n        this.z.runOutsideAngular(() => this.el[item] = val);\n      },\n      /**\n       * In the event that proxyInputs is called\n       * multiple times re-defining these inputs\n       * will cause an error to be thrown. As a result\n       * we set configurable: true to indicate these\n       * properties can be changed.\n       */\n      configurable: true\n    });\n  });\n};\nconst proxyMethods = (Cmp, methods) => {\n  const Prototype = Cmp.prototype;\n  methods.forEach(methodName => {\n    Prototype[methodName] = function () {\n      const args = arguments;\n      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n    };\n  });\n};\nconst proxyOutputs = (instance, el, events) => {\n  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));\n};\nconst defineCustomElement = (tagName, customElement) => {\n  if (customElement !== undefined && typeof customElements !== 'undefined' && !customElements.get(tagName)) {\n    customElements.define(tagName, customElement);\n  }\n};\n// tslint:disable-next-line: only-arrow-functions\nfunction ProxyCmp(opts) {\n  const decorator = function (cls) {\n    const {\n      defineCustomElementFn,\n      inputs,\n      methods\n    } = opts;\n    if (defineCustomElementFn !== undefined) {\n      defineCustomElementFn();\n    }\n    if (inputs) {\n      proxyInputs(cls, inputs);\n    }\n    if (methods) {\n      proxyMethods(cls, methods);\n    }\n    return cls;\n  };\n  return decorator;\n}\nlet IonAccordion = /*#__PURE__*/(() => {\n  let IonAccordion = class IonAccordion {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonAccordion_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonAccordion)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonAccordion,\n      selectors: [[\"ion-accordion\"]],\n      inputs: {\n        disabled: \"disabled\",\n        mode: \"mode\",\n        readonly: \"readonly\",\n        toggleIcon: \"toggleIcon\",\n        toggleIconSlot: \"toggleIconSlot\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonAccordion_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonAccordion = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$5,\n    inputs: ['disabled', 'mode', 'readonly', 'toggleIcon', 'toggleIconSlot', 'value']\n  })], IonAccordion);\n  return IonAccordion;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonAccordionGroup = /*#__PURE__*/(() => {\n  let IonAccordionGroup = class IonAccordionGroup {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonAccordionGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonAccordionGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonAccordionGroup,\n      selectors: [[\"ion-accordion-group\"]],\n      inputs: {\n        animated: \"animated\",\n        disabled: \"disabled\",\n        expand: \"expand\",\n        mode: \"mode\",\n        multiple: \"multiple\",\n        readonly: \"readonly\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonAccordionGroup_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonAccordionGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$6,\n    inputs: ['animated', 'disabled', 'expand', 'mode', 'multiple', 'readonly', 'value']\n  })], IonAccordionGroup);\n  return IonAccordionGroup;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonActionSheet = /*#__PURE__*/(() => {\n  let IonActionSheet = class IonActionSheet {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionActionSheetDidPresent', 'ionActionSheetWillPresent', 'ionActionSheetWillDismiss', 'ionActionSheetDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonActionSheet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonActionSheet)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonActionSheet,\n      selectors: [[\"ion-action-sheet\"]],\n      inputs: {\n        animated: \"animated\",\n        backdropDismiss: \"backdropDismiss\",\n        buttons: \"buttons\",\n        cssClass: \"cssClass\",\n        enterAnimation: \"enterAnimation\",\n        header: \"header\",\n        htmlAttributes: \"htmlAttributes\",\n        isOpen: \"isOpen\",\n        keyboardClose: \"keyboardClose\",\n        leaveAnimation: \"leaveAnimation\",\n        mode: \"mode\",\n        subHeader: \"subHeader\",\n        translucent: \"translucent\",\n        trigger: \"trigger\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonActionSheet_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonActionSheet = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$7,\n    inputs: ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'subHeader', 'translucent', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss']\n  })], IonActionSheet);\n  return IonActionSheet;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonAlert = /*#__PURE__*/(() => {\n  let IonAlert = class IonAlert {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionAlertDidPresent', 'ionAlertWillPresent', 'ionAlertWillDismiss', 'ionAlertDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonAlert_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonAlert)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonAlert,\n      selectors: [[\"ion-alert\"]],\n      inputs: {\n        animated: \"animated\",\n        backdropDismiss: \"backdropDismiss\",\n        buttons: \"buttons\",\n        cssClass: \"cssClass\",\n        enterAnimation: \"enterAnimation\",\n        header: \"header\",\n        htmlAttributes: \"htmlAttributes\",\n        inputs: \"inputs\",\n        isOpen: \"isOpen\",\n        keyboardClose: \"keyboardClose\",\n        leaveAnimation: \"leaveAnimation\",\n        message: \"message\",\n        mode: \"mode\",\n        subHeader: \"subHeader\",\n        translucent: \"translucent\",\n        trigger: \"trigger\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonAlert_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonAlert = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$8,\n    inputs: ['animated', 'backdropDismiss', 'buttons', 'cssClass', 'enterAnimation', 'header', 'htmlAttributes', 'inputs', 'isOpen', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'subHeader', 'translucent', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss']\n  })], IonAlert);\n  return IonAlert;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonApp = /*#__PURE__*/(() => {\n  let IonApp = class IonApp {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonApp_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonApp)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonApp,\n      selectors: [[\"ion-app\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonApp_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonApp = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$9,\n    methods: ['setFocus']\n  })], IonApp);\n  return IonApp;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonAvatar = /*#__PURE__*/(() => {\n  let IonAvatar = class IonAvatar {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonAvatar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonAvatar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonAvatar,\n      selectors: [[\"ion-avatar\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonAvatar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonAvatar = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$a\n  })], IonAvatar);\n  return IonAvatar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonBackdrop = /*#__PURE__*/(() => {\n  let IonBackdrop = class IonBackdrop {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionBackdropTap']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonBackdrop_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonBackdrop)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonBackdrop,\n      selectors: [[\"ion-backdrop\"]],\n      inputs: {\n        stopPropagation: \"stopPropagation\",\n        tappable: \"tappable\",\n        visible: \"visible\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonBackdrop_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonBackdrop = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$b,\n    inputs: ['stopPropagation', 'tappable', 'visible']\n  })], IonBackdrop);\n  return IonBackdrop;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonBadge = /*#__PURE__*/(() => {\n  let IonBadge = class IonBadge {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonBadge_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonBadge)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonBadge,\n      selectors: [[\"ion-badge\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonBadge_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonBadge = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$c,\n    inputs: ['color', 'mode']\n  })], IonBadge);\n  return IonBadge;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonBreadcrumb = /*#__PURE__*/(() => {\n  let IonBreadcrumb = class IonBreadcrumb {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonBreadcrumb_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonBreadcrumb)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonBreadcrumb,\n      selectors: [[\"ion-breadcrumb\"]],\n      inputs: {\n        active: \"active\",\n        color: \"color\",\n        disabled: \"disabled\",\n        download: \"download\",\n        href: \"href\",\n        mode: \"mode\",\n        rel: \"rel\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\",\n        separator: \"separator\",\n        target: \"target\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonBreadcrumb_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonBreadcrumb = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$d,\n    inputs: ['active', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'separator', 'target']\n  })], IonBreadcrumb);\n  return IonBreadcrumb;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonBreadcrumbs = /*#__PURE__*/(() => {\n  let IonBreadcrumbs = class IonBreadcrumbs {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionCollapsedClick']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonBreadcrumbs_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonBreadcrumbs)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonBreadcrumbs,\n      selectors: [[\"ion-breadcrumbs\"]],\n      inputs: {\n        color: \"color\",\n        itemsAfterCollapse: \"itemsAfterCollapse\",\n        itemsBeforeCollapse: \"itemsBeforeCollapse\",\n        maxItems: \"maxItems\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonBreadcrumbs_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonBreadcrumbs = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$e,\n    inputs: ['color', 'itemsAfterCollapse', 'itemsBeforeCollapse', 'maxItems', 'mode']\n  })], IonBreadcrumbs);\n  return IonBreadcrumbs;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonButton = /*#__PURE__*/(() => {\n  let IonButton = class IonButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonButton,\n      selectors: [[\"ion-button\"]],\n      inputs: {\n        buttonType: \"buttonType\",\n        color: \"color\",\n        disabled: \"disabled\",\n        download: \"download\",\n        expand: \"expand\",\n        fill: \"fill\",\n        form: \"form\",\n        href: \"href\",\n        mode: \"mode\",\n        rel: \"rel\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\",\n        shape: \"shape\",\n        size: \"size\",\n        strong: \"strong\",\n        target: \"target\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$f,\n    inputs: ['buttonType', 'color', 'disabled', 'download', 'expand', 'fill', 'form', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'shape', 'size', 'strong', 'target', 'type']\n  })], IonButton);\n  return IonButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonButtons = /*#__PURE__*/(() => {\n  let IonButtons = class IonButtons {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonButtons_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonButtons)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonButtons,\n      selectors: [[\"ion-buttons\"]],\n      inputs: {\n        collapse: \"collapse\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonButtons_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonButtons = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$g,\n    inputs: ['collapse']\n  })], IonButtons);\n  return IonButtons;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCard = /*#__PURE__*/(() => {\n  let IonCard = class IonCard {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCard_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCard)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCard,\n      selectors: [[\"ion-card\"]],\n      inputs: {\n        button: \"button\",\n        color: \"color\",\n        disabled: \"disabled\",\n        download: \"download\",\n        href: \"href\",\n        mode: \"mode\",\n        rel: \"rel\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\",\n        target: \"target\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCard_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCard = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$h,\n    inputs: ['button', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'target', 'type']\n  })], IonCard);\n  return IonCard;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCardContent = /*#__PURE__*/(() => {\n  let IonCardContent = class IonCardContent {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCardContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCardContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCardContent,\n      selectors: [[\"ion-card-content\"]],\n      inputs: {\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCardContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCardContent = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$i,\n    inputs: ['mode']\n  })], IonCardContent);\n  return IonCardContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCardHeader = /*#__PURE__*/(() => {\n  let IonCardHeader = class IonCardHeader {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCardHeader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCardHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCardHeader,\n      selectors: [[\"ion-card-header\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\",\n        translucent: \"translucent\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCardHeader_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCardHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$j,\n    inputs: ['color', 'mode', 'translucent']\n  })], IonCardHeader);\n  return IonCardHeader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCardSubtitle = /*#__PURE__*/(() => {\n  let IonCardSubtitle = class IonCardSubtitle {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCardSubtitle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCardSubtitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCardSubtitle,\n      selectors: [[\"ion-card-subtitle\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCardSubtitle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCardSubtitle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$k,\n    inputs: ['color', 'mode']\n  })], IonCardSubtitle);\n  return IonCardSubtitle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCardTitle = /*#__PURE__*/(() => {\n  let IonCardTitle = class IonCardTitle {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCardTitle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCardTitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCardTitle,\n      selectors: [[\"ion-card-title\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCardTitle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCardTitle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$l,\n    inputs: ['color', 'mode']\n  })], IonCardTitle);\n  return IonCardTitle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonChip = /*#__PURE__*/(() => {\n  let IonChip = class IonChip {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonChip_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonChip)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonChip,\n      selectors: [[\"ion-chip\"]],\n      inputs: {\n        color: \"color\",\n        disabled: \"disabled\",\n        mode: \"mode\",\n        outline: \"outline\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonChip_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonChip = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$m,\n    inputs: ['color', 'disabled', 'mode', 'outline']\n  })], IonChip);\n  return IonChip;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonCol = /*#__PURE__*/(() => {\n  let IonCol = class IonCol {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCol_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCol)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCol,\n      selectors: [[\"ion-col\"]],\n      inputs: {\n        offset: \"offset\",\n        offsetLg: \"offsetLg\",\n        offsetMd: \"offsetMd\",\n        offsetSm: \"offsetSm\",\n        offsetXl: \"offsetXl\",\n        offsetXs: \"offsetXs\",\n        pull: \"pull\",\n        pullLg: \"pullLg\",\n        pullMd: \"pullMd\",\n        pullSm: \"pullSm\",\n        pullXl: \"pullXl\",\n        pullXs: \"pullXs\",\n        push: \"push\",\n        pushLg: \"pushLg\",\n        pushMd: \"pushMd\",\n        pushSm: \"pushSm\",\n        pushXl: \"pushXl\",\n        pushXs: \"pushXs\",\n        size: \"size\",\n        sizeLg: \"sizeLg\",\n        sizeMd: \"sizeMd\",\n        sizeSm: \"sizeSm\",\n        sizeXl: \"sizeXl\",\n        sizeXs: \"sizeXs\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCol_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCol = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$n,\n    inputs: ['offset', 'offsetLg', 'offsetMd', 'offsetSm', 'offsetXl', 'offsetXs', 'pull', 'pullLg', 'pullMd', 'pullSm', 'pullXl', 'pullXs', 'push', 'pushLg', 'pushMd', 'pushSm', 'pushXl', 'pushXs', 'size', 'sizeLg', 'sizeMd', 'sizeSm', 'sizeXl', 'sizeXs']\n  })], IonCol);\n  return IonCol;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonContent = /*#__PURE__*/(() => {\n  let IonContent = class IonContent {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonContent,\n      selectors: [[\"ion-content\"]],\n      inputs: {\n        color: \"color\",\n        fixedSlotPlacement: \"fixedSlotPlacement\",\n        forceOverscroll: \"forceOverscroll\",\n        fullscreen: \"fullscreen\",\n        scrollEvents: \"scrollEvents\",\n        scrollX: \"scrollX\",\n        scrollY: \"scrollY\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonContent = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$o,\n    inputs: ['color', 'fixedSlotPlacement', 'forceOverscroll', 'fullscreen', 'scrollEvents', 'scrollX', 'scrollY'],\n    methods: ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']\n  })], IonContent);\n  return IonContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonDatetimeButton = /*#__PURE__*/(() => {\n  let IonDatetimeButton = class IonDatetimeButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonDatetimeButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonDatetimeButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonDatetimeButton,\n      selectors: [[\"ion-datetime-button\"]],\n      inputs: {\n        color: \"color\",\n        datetime: \"datetime\",\n        disabled: \"disabled\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonDatetimeButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonDatetimeButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$p,\n    inputs: ['color', 'datetime', 'disabled', 'mode']\n  })], IonDatetimeButton);\n  return IonDatetimeButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonFab = /*#__PURE__*/(() => {\n  let IonFab = class IonFab {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonFab_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonFab)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonFab,\n      selectors: [[\"ion-fab\"]],\n      inputs: {\n        activated: \"activated\",\n        edge: \"edge\",\n        horizontal: \"horizontal\",\n        vertical: \"vertical\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonFab_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonFab = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$q,\n    inputs: ['activated', 'edge', 'horizontal', 'vertical'],\n    methods: ['close']\n  })], IonFab);\n  return IonFab;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonFabButton = /*#__PURE__*/(() => {\n  let IonFabButton = class IonFabButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonFabButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonFabButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonFabButton,\n      selectors: [[\"ion-fab-button\"]],\n      inputs: {\n        activated: \"activated\",\n        closeIcon: \"closeIcon\",\n        color: \"color\",\n        disabled: \"disabled\",\n        download: \"download\",\n        href: \"href\",\n        mode: \"mode\",\n        rel: \"rel\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\",\n        show: \"show\",\n        size: \"size\",\n        target: \"target\",\n        translucent: \"translucent\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonFabButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonFabButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$r,\n    inputs: ['activated', 'closeIcon', 'color', 'disabled', 'download', 'href', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'show', 'size', 'target', 'translucent', 'type']\n  })], IonFabButton);\n  return IonFabButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonFabList = /*#__PURE__*/(() => {\n  let IonFabList = class IonFabList {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonFabList_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonFabList)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonFabList,\n      selectors: [[\"ion-fab-list\"]],\n      inputs: {\n        activated: \"activated\",\n        side: \"side\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonFabList_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonFabList = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$s,\n    inputs: ['activated', 'side']\n  })], IonFabList);\n  return IonFabList;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonFooter = /*#__PURE__*/(() => {\n  let IonFooter = class IonFooter {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonFooter_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonFooter)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonFooter,\n      selectors: [[\"ion-footer\"]],\n      inputs: {\n        collapse: \"collapse\",\n        mode: \"mode\",\n        translucent: \"translucent\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonFooter_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonFooter = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$t,\n    inputs: ['collapse', 'mode', 'translucent']\n  })], IonFooter);\n  return IonFooter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonGrid = /*#__PURE__*/(() => {\n  let IonGrid = class IonGrid {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonGrid_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonGrid)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonGrid,\n      selectors: [[\"ion-grid\"]],\n      inputs: {\n        fixed: \"fixed\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonGrid_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonGrid = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$u,\n    inputs: ['fixed']\n  })], IonGrid);\n  return IonGrid;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonHeader = /*#__PURE__*/(() => {\n  let IonHeader = class IonHeader {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonHeader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonHeader,\n      selectors: [[\"ion-header\"]],\n      inputs: {\n        collapse: \"collapse\",\n        mode: \"mode\",\n        translucent: \"translucent\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonHeader_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$v,\n    inputs: ['collapse', 'mode', 'translucent']\n  })], IonHeader);\n  return IonHeader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonImg = /*#__PURE__*/(() => {\n  let IonImg = class IonImg {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionImgWillLoad', 'ionImgDidLoad', 'ionError']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonImg_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonImg)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonImg,\n      selectors: [[\"ion-img\"]],\n      inputs: {\n        alt: \"alt\",\n        src: \"src\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonImg_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonImg = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$w,\n    inputs: ['alt', 'src']\n  })], IonImg);\n  return IonImg;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonInfiniteScroll = /*#__PURE__*/(() => {\n  let IonInfiniteScroll = class IonInfiniteScroll {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionInfinite']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonInfiniteScroll_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonInfiniteScroll)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonInfiniteScroll,\n      selectors: [[\"ion-infinite-scroll\"]],\n      inputs: {\n        disabled: \"disabled\",\n        position: \"position\",\n        threshold: \"threshold\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonInfiniteScroll_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonInfiniteScroll = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$x,\n    inputs: ['disabled', 'position', 'threshold'],\n    methods: ['complete']\n  })], IonInfiniteScroll);\n  return IonInfiniteScroll;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonInfiniteScrollContent = /*#__PURE__*/(() => {\n  let IonInfiniteScrollContent = class IonInfiniteScrollContent {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonInfiniteScrollContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonInfiniteScrollContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonInfiniteScrollContent,\n      selectors: [[\"ion-infinite-scroll-content\"]],\n      inputs: {\n        loadingSpinner: \"loadingSpinner\",\n        loadingText: \"loadingText\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonInfiniteScrollContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonInfiniteScrollContent = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$y,\n    inputs: ['loadingSpinner', 'loadingText']\n  })], IonInfiniteScrollContent);\n  return IonInfiniteScrollContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonInputPasswordToggle = /*#__PURE__*/(() => {\n  let IonInputPasswordToggle = class IonInputPasswordToggle {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonInputPasswordToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonInputPasswordToggle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonInputPasswordToggle,\n      selectors: [[\"ion-input-password-toggle\"]],\n      inputs: {\n        color: \"color\",\n        hideIcon: \"hideIcon\",\n        mode: \"mode\",\n        showIcon: \"showIcon\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonInputPasswordToggle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonInputPasswordToggle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$z,\n    inputs: ['color', 'hideIcon', 'mode', 'showIcon']\n  })], IonInputPasswordToggle);\n  return IonInputPasswordToggle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItem = /*#__PURE__*/(() => {\n  let IonItem = class IonItem {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItem_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItem)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItem,\n      selectors: [[\"ion-item\"]],\n      inputs: {\n        button: \"button\",\n        color: \"color\",\n        detail: \"detail\",\n        detailIcon: \"detailIcon\",\n        disabled: \"disabled\",\n        download: \"download\",\n        href: \"href\",\n        lines: \"lines\",\n        mode: \"mode\",\n        rel: \"rel\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\",\n        target: \"target\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItem_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItem = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$A,\n    inputs: ['button', 'color', 'detail', 'detailIcon', 'disabled', 'download', 'href', 'lines', 'mode', 'rel', 'routerAnimation', 'routerDirection', 'target', 'type']\n  })], IonItem);\n  return IonItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItemDivider = /*#__PURE__*/(() => {\n  let IonItemDivider = class IonItemDivider {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItemDivider_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItemDivider)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItemDivider,\n      selectors: [[\"ion-item-divider\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\",\n        sticky: \"sticky\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItemDivider_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItemDivider = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$B,\n    inputs: ['color', 'mode', 'sticky']\n  })], IonItemDivider);\n  return IonItemDivider;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItemGroup = /*#__PURE__*/(() => {\n  let IonItemGroup = class IonItemGroup {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItemGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItemGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItemGroup,\n      selectors: [[\"ion-item-group\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItemGroup_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItemGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$C\n  })], IonItemGroup);\n  return IonItemGroup;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItemOption = /*#__PURE__*/(() => {\n  let IonItemOption = class IonItemOption {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItemOption_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItemOption)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItemOption,\n      selectors: [[\"ion-item-option\"]],\n      inputs: {\n        color: \"color\",\n        disabled: \"disabled\",\n        download: \"download\",\n        expandable: \"expandable\",\n        href: \"href\",\n        mode: \"mode\",\n        rel: \"rel\",\n        target: \"target\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItemOption_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItemOption = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$D,\n    inputs: ['color', 'disabled', 'download', 'expandable', 'href', 'mode', 'rel', 'target', 'type']\n  })], IonItemOption);\n  return IonItemOption;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItemOptions = /*#__PURE__*/(() => {\n  let IonItemOptions = class IonItemOptions {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionSwipe']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItemOptions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItemOptions)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItemOptions,\n      selectors: [[\"ion-item-options\"]],\n      inputs: {\n        side: \"side\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItemOptions_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItemOptions = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$E,\n    inputs: ['side']\n  })], IonItemOptions);\n  return IonItemOptions;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonItemSliding = /*#__PURE__*/(() => {\n  let IonItemSliding = class IonItemSliding {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionDrag']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonItemSliding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonItemSliding)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonItemSliding,\n      selectors: [[\"ion-item-sliding\"]],\n      inputs: {\n        disabled: \"disabled\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonItemSliding_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonItemSliding = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$F,\n    inputs: ['disabled'],\n    methods: ['getOpenAmount', 'getSlidingRatio', 'open', 'close', 'closeOpened']\n  })], IonItemSliding);\n  return IonItemSliding;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonLabel = /*#__PURE__*/(() => {\n  let IonLabel = class IonLabel {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonLabel_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonLabel)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonLabel,\n      selectors: [[\"ion-label\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\",\n        position: \"position\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonLabel_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonLabel = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$G,\n    inputs: ['color', 'mode', 'position']\n  })], IonLabel);\n  return IonLabel;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonList = /*#__PURE__*/(() => {\n  let IonList = class IonList {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonList_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonList)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonList,\n      selectors: [[\"ion-list\"]],\n      inputs: {\n        inset: \"inset\",\n        lines: \"lines\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonList_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonList = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$H,\n    inputs: ['inset', 'lines', 'mode'],\n    methods: ['closeSlidingItems']\n  })], IonList);\n  return IonList;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonListHeader = /*#__PURE__*/(() => {\n  let IonListHeader = class IonListHeader {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonListHeader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonListHeader)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonListHeader,\n      selectors: [[\"ion-list-header\"]],\n      inputs: {\n        color: \"color\",\n        lines: \"lines\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonListHeader_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonListHeader = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$I,\n    inputs: ['color', 'lines', 'mode']\n  })], IonListHeader);\n  return IonListHeader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonLoading = /*#__PURE__*/(() => {\n  let IonLoading = class IonLoading {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionLoadingDidPresent', 'ionLoadingWillPresent', 'ionLoadingWillDismiss', 'ionLoadingDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonLoading_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonLoading)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonLoading,\n      selectors: [[\"ion-loading\"]],\n      inputs: {\n        animated: \"animated\",\n        backdropDismiss: \"backdropDismiss\",\n        cssClass: \"cssClass\",\n        duration: \"duration\",\n        enterAnimation: \"enterAnimation\",\n        htmlAttributes: \"htmlAttributes\",\n        isOpen: \"isOpen\",\n        keyboardClose: \"keyboardClose\",\n        leaveAnimation: \"leaveAnimation\",\n        message: \"message\",\n        mode: \"mode\",\n        showBackdrop: \"showBackdrop\",\n        spinner: \"spinner\",\n        translucent: \"translucent\",\n        trigger: \"trigger\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonLoading_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonLoading = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$J,\n    inputs: ['animated', 'backdropDismiss', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'message', 'mode', 'showBackdrop', 'spinner', 'translucent', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss']\n  })], IonLoading);\n  return IonLoading;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonMenu = /*#__PURE__*/(() => {\n  let IonMenu = class IonMenu {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonMenu_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonMenu)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonMenu,\n      selectors: [[\"ion-menu\"]],\n      inputs: {\n        contentId: \"contentId\",\n        disabled: \"disabled\",\n        maxEdgeStart: \"maxEdgeStart\",\n        menuId: \"menuId\",\n        side: \"side\",\n        swipeGesture: \"swipeGesture\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonMenu_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonMenu = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$K,\n    inputs: ['contentId', 'disabled', 'maxEdgeStart', 'menuId', 'side', 'swipeGesture', 'type'],\n    methods: ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']\n  })], IonMenu);\n  return IonMenu;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonMenuButton = /*#__PURE__*/(() => {\n  let IonMenuButton = class IonMenuButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonMenuButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonMenuButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonMenuButton,\n      selectors: [[\"ion-menu-button\"]],\n      inputs: {\n        autoHide: \"autoHide\",\n        color: \"color\",\n        disabled: \"disabled\",\n        menu: \"menu\",\n        mode: \"mode\",\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonMenuButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonMenuButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$L,\n    inputs: ['autoHide', 'color', 'disabled', 'menu', 'mode', 'type']\n  })], IonMenuButton);\n  return IonMenuButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonMenuToggle = /*#__PURE__*/(() => {\n  let IonMenuToggle = class IonMenuToggle {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonMenuToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonMenuToggle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonMenuToggle,\n      selectors: [[\"ion-menu-toggle\"]],\n      inputs: {\n        autoHide: \"autoHide\",\n        menu: \"menu\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonMenuToggle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonMenuToggle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$M,\n    inputs: ['autoHide', 'menu']\n  })], IonMenuToggle);\n  return IonMenuToggle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonNavLink = /*#__PURE__*/(() => {\n  let IonNavLink = class IonNavLink {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonNavLink_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonNavLink)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonNavLink,\n      selectors: [[\"ion-nav-link\"]],\n      inputs: {\n        component: \"component\",\n        componentProps: \"componentProps\",\n        routerAnimation: \"routerAnimation\",\n        routerDirection: \"routerDirection\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonNavLink_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonNavLink = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$N,\n    inputs: ['component', 'componentProps', 'routerAnimation', 'routerDirection']\n  })], IonNavLink);\n  return IonNavLink;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonNote = /*#__PURE__*/(() => {\n  let IonNote = class IonNote {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonNote_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonNote)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonNote,\n      selectors: [[\"ion-note\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonNote_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonNote = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$O,\n    inputs: ['color', 'mode']\n  })], IonNote);\n  return IonNote;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonPicker = /*#__PURE__*/(() => {\n  let IonPicker = class IonPicker {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonPicker_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonPicker)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonPicker,\n      selectors: [[\"ion-picker\"]],\n      inputs: {\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonPicker_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonPicker = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$P,\n    inputs: ['mode']\n  })], IonPicker);\n  return IonPicker;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonPickerColumn = /*#__PURE__*/(() => {\n  let IonPickerColumn = class IonPickerColumn {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonPickerColumn_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonPickerColumn)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonPickerColumn,\n      selectors: [[\"ion-picker-column\"]],\n      inputs: {\n        color: \"color\",\n        disabled: \"disabled\",\n        mode: \"mode\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonPickerColumn_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonPickerColumn = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$Q,\n    inputs: ['color', 'disabled', 'mode', 'value'],\n    methods: ['setFocus']\n  })], IonPickerColumn);\n  return IonPickerColumn;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonPickerColumnOption = /*#__PURE__*/(() => {\n  let IonPickerColumnOption = class IonPickerColumnOption {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonPickerColumnOption_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonPickerColumnOption)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonPickerColumnOption,\n      selectors: [[\"ion-picker-column-option\"]],\n      inputs: {\n        color: \"color\",\n        disabled: \"disabled\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonPickerColumnOption_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonPickerColumnOption = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$R,\n    inputs: ['color', 'disabled', 'value']\n  })], IonPickerColumnOption);\n  return IonPickerColumnOption;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonPickerLegacy = /*#__PURE__*/(() => {\n  let IonPickerLegacy = class IonPickerLegacy {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionPickerDidPresent', 'ionPickerWillPresent', 'ionPickerWillDismiss', 'ionPickerDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonPickerLegacy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonPickerLegacy)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonPickerLegacy,\n      selectors: [[\"ion-picker-legacy\"]],\n      inputs: {\n        animated: \"animated\",\n        backdropDismiss: \"backdropDismiss\",\n        buttons: \"buttons\",\n        columns: \"columns\",\n        cssClass: \"cssClass\",\n        duration: \"duration\",\n        enterAnimation: \"enterAnimation\",\n        htmlAttributes: \"htmlAttributes\",\n        isOpen: \"isOpen\",\n        keyboardClose: \"keyboardClose\",\n        leaveAnimation: \"leaveAnimation\",\n        mode: \"mode\",\n        showBackdrop: \"showBackdrop\",\n        trigger: \"trigger\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonPickerLegacy_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonPickerLegacy = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$S,\n    inputs: ['animated', 'backdropDismiss', 'buttons', 'columns', 'cssClass', 'duration', 'enterAnimation', 'htmlAttributes', 'isOpen', 'keyboardClose', 'leaveAnimation', 'mode', 'showBackdrop', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss', 'getColumn']\n  })], IonPickerLegacy);\n  return IonPickerLegacy;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonProgressBar = /*#__PURE__*/(() => {\n  let IonProgressBar = class IonProgressBar {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonProgressBar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonProgressBar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonProgressBar,\n      selectors: [[\"ion-progress-bar\"]],\n      inputs: {\n        buffer: \"buffer\",\n        color: \"color\",\n        mode: \"mode\",\n        reversed: \"reversed\",\n        type: \"type\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonProgressBar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonProgressBar = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$T,\n    inputs: ['buffer', 'color', 'mode', 'reversed', 'type', 'value']\n  })], IonProgressBar);\n  return IonProgressBar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonRadio = /*#__PURE__*/(() => {\n  let IonRadio = class IonRadio {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRadio_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRadio)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRadio,\n      selectors: [[\"ion-radio\"]],\n      inputs: {\n        alignment: \"alignment\",\n        color: \"color\",\n        disabled: \"disabled\",\n        justify: \"justify\",\n        labelPlacement: \"labelPlacement\",\n        mode: \"mode\",\n        name: \"name\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRadio_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRadio = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$U,\n    inputs: ['alignment', 'color', 'disabled', 'justify', 'labelPlacement', 'mode', 'name', 'value']\n  })], IonRadio);\n  return IonRadio;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonRefresher = /*#__PURE__*/(() => {\n  let IonRefresher = class IonRefresher {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRefresher_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRefresher)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRefresher,\n      selectors: [[\"ion-refresher\"]],\n      inputs: {\n        closeDuration: \"closeDuration\",\n        disabled: \"disabled\",\n        mode: \"mode\",\n        pullFactor: \"pullFactor\",\n        pullMax: \"pullMax\",\n        pullMin: \"pullMin\",\n        snapbackDuration: \"snapbackDuration\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRefresher_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRefresher = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$V,\n    inputs: ['closeDuration', 'disabled', 'mode', 'pullFactor', 'pullMax', 'pullMin', 'snapbackDuration'],\n    methods: ['complete', 'cancel', 'getProgress']\n  })], IonRefresher);\n  return IonRefresher;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonRefresherContent = /*#__PURE__*/(() => {\n  let IonRefresherContent = class IonRefresherContent {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRefresherContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRefresherContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRefresherContent,\n      selectors: [[\"ion-refresher-content\"]],\n      inputs: {\n        pullingIcon: \"pullingIcon\",\n        pullingText: \"pullingText\",\n        refreshingSpinner: \"refreshingSpinner\",\n        refreshingText: \"refreshingText\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRefresherContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRefresherContent = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$W,\n    inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']\n  })], IonRefresherContent);\n  return IonRefresherContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonReorder = /*#__PURE__*/(() => {\n  let IonReorder = class IonReorder {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonReorder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonReorder)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonReorder,\n      selectors: [[\"ion-reorder\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonReorder_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonReorder = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$X\n  })], IonReorder);\n  return IonReorder;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonReorderGroup = /*#__PURE__*/(() => {\n  let IonReorderGroup = class IonReorderGroup {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionItemReorder', 'ionReorderStart', 'ionReorderMove', 'ionReorderEnd']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonReorderGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonReorderGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonReorderGroup,\n      selectors: [[\"ion-reorder-group\"]],\n      inputs: {\n        disabled: \"disabled\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonReorderGroup_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonReorderGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$Y,\n    inputs: ['disabled'],\n    methods: ['complete']\n  })], IonReorderGroup);\n  return IonReorderGroup;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonRippleEffect = /*#__PURE__*/(() => {\n  let IonRippleEffect = class IonRippleEffect {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRippleEffect_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRippleEffect)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRippleEffect,\n      selectors: [[\"ion-ripple-effect\"]],\n      inputs: {\n        type: \"type\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRippleEffect_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRippleEffect = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$Z,\n    inputs: ['type'],\n    methods: ['addRipple']\n  })], IonRippleEffect);\n  return IonRippleEffect;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonRow = /*#__PURE__*/(() => {\n  let IonRow = class IonRow {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRow_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRow)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRow,\n      selectors: [[\"ion-row\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRow = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$_\n  })], IonRow);\n  return IonRow;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSegmentButton = /*#__PURE__*/(() => {\n  let IonSegmentButton = class IonSegmentButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSegmentButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSegmentButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSegmentButton,\n      selectors: [[\"ion-segment-button\"]],\n      inputs: {\n        contentId: \"contentId\",\n        disabled: \"disabled\",\n        layout: \"layout\",\n        mode: \"mode\",\n        type: \"type\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSegmentButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSegmentButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$$,\n    inputs: ['contentId', 'disabled', 'layout', 'mode', 'type', 'value']\n  })], IonSegmentButton);\n  return IonSegmentButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSegmentContent = /*#__PURE__*/(() => {\n  let IonSegmentContent = class IonSegmentContent {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSegmentContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSegmentContent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSegmentContent,\n      selectors: [[\"ion-segment-content\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSegmentContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSegmentContent = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$10\n  })], IonSegmentContent);\n  return IonSegmentContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSegmentView = /*#__PURE__*/(() => {\n  let IonSegmentView = class IonSegmentView {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionSegmentViewScroll']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSegmentView_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSegmentView)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSegmentView,\n      selectors: [[\"ion-segment-view\"]],\n      inputs: {\n        disabled: \"disabled\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSegmentView_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSegmentView = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$11,\n    inputs: ['disabled']\n  })], IonSegmentView);\n  return IonSegmentView;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSelectModal = /*#__PURE__*/(() => {\n  let IonSelectModal = class IonSelectModal {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSelectModal_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSelectModal)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSelectModal,\n      selectors: [[\"ion-select-modal\"]],\n      inputs: {\n        header: \"header\",\n        multiple: \"multiple\",\n        options: \"options\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSelectModal_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSelectModal = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$12,\n    inputs: ['header', 'multiple', 'options']\n  })], IonSelectModal);\n  return IonSelectModal;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSelectOption = /*#__PURE__*/(() => {\n  let IonSelectOption = class IonSelectOption {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSelectOption_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSelectOption)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSelectOption,\n      selectors: [[\"ion-select-option\"]],\n      inputs: {\n        disabled: \"disabled\",\n        value: \"value\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSelectOption_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSelectOption = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$13,\n    inputs: ['disabled', 'value']\n  })], IonSelectOption);\n  return IonSelectOption;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSkeletonText = /*#__PURE__*/(() => {\n  let IonSkeletonText = class IonSkeletonText {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSkeletonText_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSkeletonText)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSkeletonText,\n      selectors: [[\"ion-skeleton-text\"]],\n      inputs: {\n        animated: \"animated\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSkeletonText_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSkeletonText = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$14,\n    inputs: ['animated']\n  })], IonSkeletonText);\n  return IonSkeletonText;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSpinner = /*#__PURE__*/(() => {\n  let IonSpinner = class IonSpinner {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSpinner_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSpinner)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSpinner,\n      selectors: [[\"ion-spinner\"]],\n      inputs: {\n        color: \"color\",\n        duration: \"duration\",\n        name: \"name\",\n        paused: \"paused\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSpinner_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSpinner = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$15,\n    inputs: ['color', 'duration', 'name', 'paused']\n  })], IonSpinner);\n  return IonSpinner;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonSplitPane = /*#__PURE__*/(() => {\n  let IonSplitPane = class IonSplitPane {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionSplitPaneVisible']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSplitPane_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSplitPane)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSplitPane,\n      selectors: [[\"ion-split-pane\"]],\n      inputs: {\n        contentId: \"contentId\",\n        disabled: \"disabled\",\n        when: \"when\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSplitPane_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSplitPane = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$16,\n    inputs: ['contentId', 'disabled', 'when']\n  })], IonSplitPane);\n  return IonSplitPane;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonTab = /*#__PURE__*/(() => {\n  let IonTab = class IonTab {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonTab_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonTab)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTab,\n      selectors: [[\"ion-tab\"]],\n      inputs: {\n        component: \"component\",\n        tab: \"tab\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonTab_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonTab = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$17,\n    inputs: ['component', 'tab'],\n    methods: ['setActive']\n  })], IonTab);\n  return IonTab;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonTabBar = /*#__PURE__*/(() => {\n  let IonTabBar = class IonTabBar {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonTabBar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonTabBar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTabBar,\n      selectors: [[\"ion-tab-bar\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\",\n        selectedTab: \"selectedTab\",\n        translucent: \"translucent\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonTabBar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonTabBar = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$18,\n    inputs: ['color', 'mode', 'selectedTab', 'translucent']\n  })], IonTabBar);\n  return IonTabBar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonTabButton = /*#__PURE__*/(() => {\n  let IonTabButton = class IonTabButton {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonTabButton_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonTabButton)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTabButton,\n      selectors: [[\"ion-tab-button\"]],\n      inputs: {\n        disabled: \"disabled\",\n        download: \"download\",\n        href: \"href\",\n        layout: \"layout\",\n        mode: \"mode\",\n        rel: \"rel\",\n        selected: \"selected\",\n        tab: \"tab\",\n        target: \"target\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonTabButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonTabButton = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$19,\n    inputs: ['disabled', 'download', 'href', 'layout', 'mode', 'rel', 'selected', 'tab', 'target']\n  })], IonTabButton);\n  return IonTabButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonText = /*#__PURE__*/(() => {\n  let IonText = class IonText {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonText_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonText)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonText,\n      selectors: [[\"ion-text\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonText_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonText = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1a,\n    inputs: ['color', 'mode']\n  })], IonText);\n  return IonText;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonThumbnail = /*#__PURE__*/(() => {\n  let IonThumbnail = class IonThumbnail {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonThumbnail_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonThumbnail)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonThumbnail,\n      selectors: [[\"ion-thumbnail\"]],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonThumbnail_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonThumbnail = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1b\n  })], IonThumbnail);\n  return IonThumbnail;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonTitle = /*#__PURE__*/(() => {\n  let IonTitle = class IonTitle {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonTitle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonTitle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTitle,\n      selectors: [[\"ion-title\"]],\n      inputs: {\n        color: \"color\",\n        size: \"size\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonTitle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonTitle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1c,\n    inputs: ['color', 'size']\n  })], IonTitle);\n  return IonTitle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonToast = /*#__PURE__*/(() => {\n  let IonToast = class IonToast {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionToastDidPresent', 'ionToastWillPresent', 'ionToastWillDismiss', 'ionToastDidDismiss', 'didPresent', 'willPresent', 'willDismiss', 'didDismiss']);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonToast_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonToast)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonToast,\n      selectors: [[\"ion-toast\"]],\n      inputs: {\n        animated: \"animated\",\n        buttons: \"buttons\",\n        color: \"color\",\n        cssClass: \"cssClass\",\n        duration: \"duration\",\n        enterAnimation: \"enterAnimation\",\n        header: \"header\",\n        htmlAttributes: \"htmlAttributes\",\n        icon: \"icon\",\n        isOpen: \"isOpen\",\n        keyboardClose: \"keyboardClose\",\n        layout: \"layout\",\n        leaveAnimation: \"leaveAnimation\",\n        message: \"message\",\n        mode: \"mode\",\n        position: \"position\",\n        positionAnchor: \"positionAnchor\",\n        swipeGesture: \"swipeGesture\",\n        translucent: \"translucent\",\n        trigger: \"trigger\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonToast_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonToast = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1d,\n    inputs: ['animated', 'buttons', 'color', 'cssClass', 'duration', 'enterAnimation', 'header', 'htmlAttributes', 'icon', 'isOpen', 'keyboardClose', 'layout', 'leaveAnimation', 'message', 'mode', 'position', 'positionAnchor', 'swipeGesture', 'translucent', 'trigger'],\n    methods: ['present', 'dismiss', 'onDidDismiss', 'onWillDismiss']\n  })], IonToast);\n  return IonToast;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonToolbar = /*#__PURE__*/(() => {\n  let IonToolbar = class IonToolbar {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonToolbar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonToolbar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonToolbar,\n      selectors: [[\"ion-toolbar\"]],\n      inputs: {\n        color: \"color\",\n        mode: \"mode\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonToolbar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonToolbar = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1e,\n    inputs: ['color', 'mode']\n  })], IonToolbar);\n  return IonToolbar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// eslint-disable-next-line @angular-eslint/component-class-suffix\nlet IonTabs = /*#__PURE__*/(() => {\n  class IonTabs extends IonTabs$1 {\n    outlet;\n    tabBar;\n    tabBars;\n    tabs;\n    /** @nocollapse */\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵIonTabs_BaseFactory;\n      return function IonTabs_Factory(__ngFactoryType__) {\n        return (ɵIonTabs_BaseFactory || (ɵIonTabs_BaseFactory = i0.ɵɵgetInheritedFactory(IonTabs)))(__ngFactoryType__ || IonTabs);\n      };\n    })();\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTabs,\n      selectors: [[\"ion-tabs\"]],\n      contentQueries: function IonTabs_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, IonTabBar, 5);\n          i0.ɵɵcontentQuery(dirIndex, IonTabBar, 4);\n          i0.ɵɵcontentQuery(dirIndex, IonTab, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabBar = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabBars = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tabs = _t);\n        }\n      },\n      viewQuery: function IonTabs_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c2, 5, IonRouterOutlet);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.outlet = _t.first);\n        }\n      },\n      features: [i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c4,\n      decls: 6,\n      vars: 2,\n      consts: [[\"tabsInner\", \"\"], [\"outlet\", \"\"], [1, \"tabs-inner\"], [\"tabs\", \"true\", 3, \"stackWillChange\", \"stackDidChange\", 4, \"ngIf\"], [4, \"ngIf\"], [\"tabs\", \"true\", 3, \"stackWillChange\", \"stackDidChange\"]],\n      template: function IonTabs_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c3);\n          i0.ɵɵprojection(0);\n          i0.ɵɵelementStart(1, \"div\", 2, 0);\n          i0.ɵɵtemplate(3, IonTabs_ion_router_outlet_3_Template, 2, 0, \"ion-router-outlet\", 3)(4, IonTabs_ng_content_4_Template, 1, 0, \"ng-content\", 4);\n          i0.ɵɵelementEnd();\n          i0.ɵɵprojection(5, 1);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"ngIf\", ctx.tabs.length === 0);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngIf\", ctx.tabs.length > 0);\n        }\n      },\n      dependencies: [IonRouterOutlet, NgIf],\n      styles: [\"[_nghost-%COMP%]{display:flex;position:absolute;inset:0;flex-direction:column;width:100%;height:100%;contain:layout size style}.tabs-inner[_ngcontent-%COMP%]{position:relative;flex:1;contain:layout size style}\"]\n    });\n  }\n  return IonTabs;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ModalController = /*#__PURE__*/(() => {\n  class ModalController extends OverlayBaseController {\n    angularDelegate = inject(AngularDelegate);\n    injector = inject(Injector);\n    environmentInjector = inject(EnvironmentInjector);\n    constructor() {\n      super(modalController);\n      defineCustomElement$3();\n    }\n    create(opts) {\n      return super.create({\n        ...opts,\n        delegate: this.angularDelegate.create(this.environmentInjector, this.injector, 'modal')\n      });\n    }\n    /** @nocollapse */\n    static ɵfac = function ModalController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ModalController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ModalController,\n      factory: ModalController.ɵfac\n    });\n  }\n  return ModalController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass PopoverController extends OverlayBaseController {\n  angularDelegate = inject(AngularDelegate);\n  injector = inject(Injector);\n  environmentInjector = inject(EnvironmentInjector);\n  constructor() {\n    super(popoverController);\n    defineCustomElement$4();\n  }\n  create(opts) {\n    return super.create({\n      ...opts,\n      delegate: this.angularDelegate.create(this.environmentInjector, this.injector, 'popover')\n    });\n  }\n}\nconst provideIonicAngular = (config = {}) => {\n  return makeEnvironmentProviders([{\n    provide: ConfigToken,\n    useValue: config\n  }, {\n    provide: APP_INITIALIZER,\n    useFactory: initializeIonicAngular,\n    multi: true,\n    deps: [ConfigToken, DOCUMENT]\n  }, provideComponentInputBinding(), AngularDelegate, ModalController, PopoverController]);\n};\nconst initializeIonicAngular = (config, doc) => {\n  return () => {\n    /**\n     * By default Ionic Framework hides elements that\n     * are not hydrated, but in the CE build there is no\n     * hydration.\n     * TODO FW-2797: Remove when all integrations have been\n     * migrated to CE build.\n     */\n    doc.documentElement.classList.add('ion-ce');\n    initialize(config);\n  };\n};\nlet ActionSheetController = /*#__PURE__*/(() => {\n  class ActionSheetController extends OverlayBaseController {\n    constructor() {\n      super(actionSheetController);\n      defineCustomElement$7();\n    }\n    /** @nocollapse */\n    static ɵfac = function ActionSheetController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ActionSheetController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ActionSheetController,\n      factory: ActionSheetController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ActionSheetController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlertController = /*#__PURE__*/(() => {\n  class AlertController extends OverlayBaseController {\n    constructor() {\n      super(alertController);\n      defineCustomElement$8();\n    }\n    /** @nocollapse */\n    static ɵfac = function AlertController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AlertController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AlertController,\n      factory: AlertController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AlertController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnimationController = /*#__PURE__*/(() => {\n  class AnimationController {\n    /**\n     * Create a new animation\n     */\n    create(animationId) {\n      return createAnimation(animationId);\n    }\n    /**\n     * EXPERIMENTAL\n     *\n     * Given a progression and a cubic bezier function,\n     * this utility returns the time value(s) at which the\n     * cubic bezier reaches the given time progression.\n     *\n     * If the cubic bezier never reaches the progression\n     * the result will be an empty array.\n     *\n     * This is most useful for switching between easing curves\n     * when doing a gesture animation (i.e. going from linear easing\n     * during a drag, to another easing when `progressEnd` is called)\n     */\n    easingTime(p0, p1, p2, p3, progression) {\n      return getTimeGivenProgression(p0, p1, p2, p3, progression);\n    }\n    /** @nocollapse */\n    static ɵfac = function AnimationController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AnimationController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AnimationController,\n      factory: AnimationController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AnimationController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GestureController = /*#__PURE__*/(() => {\n  class GestureController {\n    zone;\n    constructor(zone) {\n      this.zone = zone;\n    }\n    /**\n     * Create a new gesture\n     */\n    create(opts, runInsideAngularZone = false) {\n      if (runInsideAngularZone) {\n        Object.getOwnPropertyNames(opts).forEach(key => {\n          if (typeof opts[key] === 'function') {\n            const fn = opts[key];\n            opts[key] = (...props) => this.zone.run(() => fn(...props));\n          }\n        });\n      }\n      return createGesture(opts);\n    }\n    /** @nocollapse */\n    static ɵfac = function GestureController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GestureController)(i0.ɵɵinject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: GestureController,\n      factory: GestureController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return GestureController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LoadingController = /*#__PURE__*/(() => {\n  class LoadingController extends OverlayBaseController {\n    constructor() {\n      super(loadingController);\n      defineCustomElement$J();\n    }\n    /** @nocollapse */\n    static ɵfac = function LoadingController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || LoadingController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LoadingController,\n      factory: LoadingController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return LoadingController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MenuController = /*#__PURE__*/(() => {\n  class MenuController extends MenuController$1 {\n    constructor() {\n      super(menuController);\n    }\n    /** @nocollapse */\n    static ɵfac = function MenuController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MenuController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MenuController,\n      factory: MenuController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return MenuController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated Use the inline ion-picker component instead.\n */\nlet PickerController = /*#__PURE__*/(() => {\n  class PickerController extends OverlayBaseController {\n    constructor() {\n      super(pickerController);\n      defineCustomElement$S();\n    }\n    /** @nocollapse */\n    static ɵfac = function PickerController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PickerController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PickerController,\n      factory: PickerController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PickerController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ToastController = /*#__PURE__*/(() => {\n  class ToastController extends OverlayBaseController {\n    constructor() {\n      super(toastController);\n      defineCustomElement$1d();\n    }\n    /** @nocollapse */\n    static ɵfac = function ToastController_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ToastController)();\n    };\n    /** @nocollapse */\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ToastController,\n      factory: ToastController.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ToastController;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonNav = /*#__PURE__*/(() => {\n  let IonNav = class IonNav extends IonNav$1 {\n    constructor(ref, environmentInjector, injector, angularDelegate, z, c) {\n      super(ref, environmentInjector, injector, angularDelegate, z, c);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonNav_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonNav)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.EnvironmentInjector), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i2$1.AngularDelegate), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonNav,\n      selectors: [[\"ion-nav\"]],\n      features: [i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonNav_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2\n    });\n  };\n  IonNav = __decorate([ProxyCmp$1({\n    defineCustomElementFn: defineCustomElement$1f\n  })], IonNav);\n  return IonNav;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CHECKBOX_INPUTS = ['checked', 'color', 'disabled', 'errorText', 'helperText', 'indeterminate', 'justify', 'labelPlacement', 'mode', 'name', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$a = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonCheckbox),\n  multi: true\n};\nlet IonCheckbox = /*#__PURE__*/(() => {\n  let IonCheckbox = class IonCheckbox extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n    }\n    writeValue(value) {\n      this.elementRef.nativeElement.checked = this.lastValue = value;\n      setIonicClasses(this.elementRef);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.checked);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonCheckbox_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonCheckbox)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonCheckbox,\n      selectors: [[\"ion-checkbox\"]],\n      hostBindings: function IonCheckbox_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonCheckbox_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        checked: \"checked\",\n        color: \"color\",\n        disabled: \"disabled\",\n        errorText: \"errorText\",\n        helperText: \"helperText\",\n        indeterminate: \"indeterminate\",\n        justify: \"justify\",\n        labelPlacement: \"labelPlacement\",\n        mode: \"mode\",\n        name: \"name\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$a]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonCheckbox_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonCheckbox = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1g,\n    inputs: CHECKBOX_INPUTS\n  })], IonCheckbox);\n  return IonCheckbox;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DATETIME_INPUTS = ['cancelText', 'clearText', 'color', 'dayValues', 'disabled', 'doneText', 'firstDayOfWeek', 'formatOptions', 'highlightedDates', 'hourCycle', 'hourValues', 'isDateEnabled', 'locale', 'max', 'min', 'minuteValues', 'mode', 'monthValues', 'multiple', 'name', 'preferWheel', 'presentation', 'readonly', 'showAdjacentDays', 'showClearButton', 'showDefaultButtons', 'showDefaultTimeLabel', 'showDefaultTitle', 'size', 'titleSelectedDatesFormatter', 'value', 'yearValues'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n\n */\nconst accessorProvider$9 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonDatetime),\n  multi: true\n};\nlet IonDatetime = /*#__PURE__*/(() => {\n  let IonDatetime = class IonDatetime extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonDatetime_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonDatetime)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonDatetime,\n      selectors: [[\"ion-datetime\"]],\n      hostBindings: function IonDatetime_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonDatetime_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        cancelText: \"cancelText\",\n        clearText: \"clearText\",\n        color: \"color\",\n        dayValues: \"dayValues\",\n        disabled: \"disabled\",\n        doneText: \"doneText\",\n        firstDayOfWeek: \"firstDayOfWeek\",\n        formatOptions: \"formatOptions\",\n        highlightedDates: \"highlightedDates\",\n        hourCycle: \"hourCycle\",\n        hourValues: \"hourValues\",\n        isDateEnabled: \"isDateEnabled\",\n        locale: \"locale\",\n        max: \"max\",\n        min: \"min\",\n        minuteValues: \"minuteValues\",\n        mode: \"mode\",\n        monthValues: \"monthValues\",\n        multiple: \"multiple\",\n        name: \"name\",\n        preferWheel: \"preferWheel\",\n        presentation: \"presentation\",\n        readonly: \"readonly\",\n        showAdjacentDays: \"showAdjacentDays\",\n        showClearButton: \"showClearButton\",\n        showDefaultButtons: \"showDefaultButtons\",\n        showDefaultTimeLabel: \"showDefaultTimeLabel\",\n        showDefaultTitle: \"showDefaultTitle\",\n        size: \"size\",\n        titleSelectedDatesFormatter: \"titleSelectedDatesFormatter\",\n        value: \"value\",\n        yearValues: \"yearValues\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$9]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonDatetime_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonDatetime = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1h,\n    inputs: DATETIME_INPUTS,\n    methods: ['confirm', 'reset', 'cancel']\n  })], IonDatetime);\n  return IonDatetime;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IonIcon = /*#__PURE__*/(() => {\n  let IonIcon = class IonIcon {\n    z;\n    el;\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n    /** @nocollapse */\n    static ɵfac = function IonIcon_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonIcon)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonIcon,\n      selectors: [[\"ion-icon\"]],\n      inputs: {\n        color: \"color\",\n        flipRtl: \"flipRtl\",\n        icon: \"icon\",\n        ios: \"ios\",\n        lazy: \"lazy\",\n        md: \"md\",\n        mode: \"mode\",\n        name: \"name\",\n        sanitize: \"sanitize\",\n        size: \"size\",\n        src: \"src\"\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonIcon_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonIcon = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1i,\n    inputs: ['color', 'flipRtl', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'sanitize', 'size', 'src']\n  })], IonIcon);\n  return IonIcon;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INPUT_INPUTS = ['accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'color', 'counter', 'counterFormatter', 'debounce', 'disabled', 'enterkeyhint', 'errorText', 'fill', 'helperText', 'inputmode', 'label', 'labelPlacement', 'max', 'maxlength', 'min', 'minlength', 'mode', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'shape', 'size', 'spellcheck', 'step', 'type', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$8 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonInput),\n  multi: true\n};\nlet IonInput = /*#__PURE__*/(() => {\n  let IonInput = class IonInput extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);\n    }\n    handleIonInput(el) {\n      this.handleValueChange(el, el.value);\n    }\n    registerOnChange(fn) {\n      super.registerOnChange(value => {\n        if (this.type === 'number') {\n          /**\n           * If the input type is `number`, we need to convert the value to a number\n           * when the value is not empty. If the value is empty, we want to treat\n           * the value as null.\n           */\n          fn(value === '' ? null : parseFloat(value));\n        } else {\n          fn(value);\n        }\n      });\n    }\n    /** @nocollapse */\n    static ɵfac = function IonInput_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonInput)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonInput,\n      selectors: [[\"ion-input\"]],\n      hostBindings: function IonInput_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionInput\", function IonInput_ionInput_HostBindingHandler($event) {\n            return ctx.handleIonInput($event.target);\n          });\n        }\n      },\n      inputs: {\n        accept: \"accept\",\n        autocapitalize: \"autocapitalize\",\n        autocomplete: \"autocomplete\",\n        autocorrect: \"autocorrect\",\n        autofocus: \"autofocus\",\n        clearInput: \"clearInput\",\n        clearOnEdit: \"clearOnEdit\",\n        color: \"color\",\n        counter: \"counter\",\n        counterFormatter: \"counterFormatter\",\n        debounce: \"debounce\",\n        disabled: \"disabled\",\n        enterkeyhint: \"enterkeyhint\",\n        errorText: \"errorText\",\n        fill: \"fill\",\n        helperText: \"helperText\",\n        inputmode: \"inputmode\",\n        label: \"label\",\n        labelPlacement: \"labelPlacement\",\n        max: \"max\",\n        maxlength: \"maxlength\",\n        min: \"min\",\n        minlength: \"minlength\",\n        mode: \"mode\",\n        multiple: \"multiple\",\n        name: \"name\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        readonly: \"readonly\",\n        required: \"required\",\n        shape: \"shape\",\n        size: \"size\",\n        spellcheck: \"spellcheck\",\n        step: \"step\",\n        type: \"type\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$8]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonInput_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonInput = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1j,\n    inputs: INPUT_INPUTS,\n    methods: ['setFocus', 'getInputElement']\n  })], IonInput);\n  return IonInput;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INPUT_OTP_INPUTS = ['autocapitalize', 'color', 'disabled', 'fill', 'inputmode', 'length', 'pattern', 'readonly', 'separators', 'shape', 'size', 'type', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$7 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonInputOtp),\n  multi: true\n};\nlet IonInputOtp = /*#__PURE__*/(() => {\n  let IonInputOtp = class IonInputOtp extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionComplete', 'ionBlur', 'ionFocus']);\n    }\n    handleIonInput(el) {\n      this.handleValueChange(el, el.value);\n    }\n    registerOnChange(fn) {\n      super.registerOnChange(value => {\n        if (this.type === 'number') {\n          /**\n           * If the input type is `number`, we need to convert the value to a number\n           * when the value is not empty. If the value is empty, we want to treat\n           * the value as null.\n           */\n          fn(value === '' ? null : parseFloat(value));\n        } else {\n          fn(value);\n        }\n      });\n    }\n    /** @nocollapse */\n    static ɵfac = function IonInputOtp_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonInputOtp)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonInputOtp,\n      selectors: [[\"ion-input-otp\"]],\n      hostBindings: function IonInputOtp_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionInput\", function IonInputOtp_ionInput_HostBindingHandler($event) {\n            return ctx.handleIonInput($event.target);\n          });\n        }\n      },\n      inputs: {\n        autocapitalize: \"autocapitalize\",\n        color: \"color\",\n        disabled: \"disabled\",\n        fill: \"fill\",\n        inputmode: \"inputmode\",\n        length: \"length\",\n        pattern: \"pattern\",\n        readonly: \"readonly\",\n        separators: \"separators\",\n        shape: \"shape\",\n        size: \"size\",\n        type: \"type\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$7]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonInputOtp_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonInputOtp = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1k,\n    inputs: INPUT_OTP_INPUTS,\n    methods: ['setFocus']\n  })], IonInputOtp);\n  return IonInputOtp;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst RADIO_GROUP_INPUTS = ['allowEmptySelection', 'compareWith', 'errorText', 'helperText', 'name', 'value'];\n/**\n * Pulling the provider into an object and using PURE  works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$6 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonRadioGroup),\n  multi: true\n};\nlet IonRadioGroup = /*#__PURE__*/(() => {\n  let IonRadioGroup = class IonRadioGroup extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange']);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRadioGroup_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRadioGroup)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRadioGroup,\n      selectors: [[\"ion-radio-group\"]],\n      hostBindings: function IonRadioGroup_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonRadioGroup_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        allowEmptySelection: \"allowEmptySelection\",\n        compareWith: \"compareWith\",\n        errorText: \"errorText\",\n        helperText: \"helperText\",\n        name: \"name\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$6]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRadioGroup_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRadioGroup = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1l,\n    inputs: RADIO_GROUP_INPUTS\n  })], IonRadioGroup);\n  return IonRadioGroup;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst RANGE_INPUTS = ['activeBarStart', 'color', 'debounce', 'disabled', 'dualKnobs', 'label', 'labelPlacement', 'max', 'min', 'mode', 'name', 'pin', 'pinFormatter', 'snaps', 'step', 'ticks', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$5 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonRange),\n  multi: true\n};\nlet IonRange = /*#__PURE__*/(() => {\n  let IonRange = class IonRange extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionFocus', 'ionBlur', 'ionKnobMoveStart', 'ionKnobMoveEnd']);\n    }\n    handleIonInput(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonRange_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonRange)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonRange,\n      selectors: [[\"ion-range\"]],\n      hostBindings: function IonRange_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionInput\", function IonRange_ionInput_HostBindingHandler($event) {\n            return ctx.handleIonInput($event.target);\n          });\n        }\n      },\n      inputs: {\n        activeBarStart: \"activeBarStart\",\n        color: \"color\",\n        debounce: \"debounce\",\n        disabled: \"disabled\",\n        dualKnobs: \"dualKnobs\",\n        label: \"label\",\n        labelPlacement: \"labelPlacement\",\n        max: \"max\",\n        min: \"min\",\n        mode: \"mode\",\n        name: \"name\",\n        pin: \"pin\",\n        pinFormatter: \"pinFormatter\",\n        snaps: \"snaps\",\n        step: \"step\",\n        ticks: \"ticks\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$5]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonRange_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonRange = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1m,\n    inputs: RANGE_INPUTS\n  })], IonRange);\n  return IonRange;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SEARCHBAR_INPUTS = ['animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'color', 'debounce', 'disabled', 'enterkeyhint', 'inputmode', 'mode', 'name', 'placeholder', 'searchIcon', 'showCancelButton', 'showClearButton', 'spellcheck', 'type', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$4 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonSearchbar),\n  multi: true\n};\nlet IonSearchbar = /*#__PURE__*/(() => {\n  let IonSearchbar = class IonSearchbar extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);\n    }\n    handleIonInput(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSearchbar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSearchbar)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSearchbar,\n      selectors: [[\"ion-searchbar\"]],\n      hostBindings: function IonSearchbar_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionInput\", function IonSearchbar_ionInput_HostBindingHandler($event) {\n            return ctx.handleIonInput($event.target);\n          });\n        }\n      },\n      inputs: {\n        animated: \"animated\",\n        autocomplete: \"autocomplete\",\n        autocorrect: \"autocorrect\",\n        cancelButtonIcon: \"cancelButtonIcon\",\n        cancelButtonText: \"cancelButtonText\",\n        clearIcon: \"clearIcon\",\n        color: \"color\",\n        debounce: \"debounce\",\n        disabled: \"disabled\",\n        enterkeyhint: \"enterkeyhint\",\n        inputmode: \"inputmode\",\n        mode: \"mode\",\n        name: \"name\",\n        placeholder: \"placeholder\",\n        searchIcon: \"searchIcon\",\n        showCancelButton: \"showCancelButton\",\n        showClearButton: \"showClearButton\",\n        spellcheck: \"spellcheck\",\n        type: \"type\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$4]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSearchbar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSearchbar = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1n,\n    inputs: SEARCHBAR_INPUTS,\n    methods: ['setFocus', 'getInputElement']\n  })], IonSearchbar);\n  return IonSearchbar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SEGMENT_INPUTS = ['color', 'disabled', 'mode', 'scrollable', 'selectOnFocus', 'swipeGesture', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$3 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonSegment),\n  multi: true\n};\nlet IonSegment = /*#__PURE__*/(() => {\n  let IonSegment = class IonSegment extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange']);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSegment_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSegment)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSegment,\n      selectors: [[\"ion-segment\"]],\n      hostBindings: function IonSegment_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonSegment_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        color: \"color\",\n        disabled: \"disabled\",\n        mode: \"mode\",\n        scrollable: \"scrollable\",\n        selectOnFocus: \"selectOnFocus\",\n        swipeGesture: \"swipeGesture\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$3]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSegment_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSegment = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1o,\n    inputs: SEGMENT_INPUTS\n  })], IonSegment);\n  return IonSegment;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SELECT_INPUTS = ['cancelText', 'color', 'compareWith', 'disabled', 'errorText', 'expandedIcon', 'fill', 'helperText', 'interface', 'interfaceOptions', 'justify', 'label', 'labelPlacement', 'mode', 'multiple', 'name', 'okText', 'placeholder', 'selectedText', 'shape', 'toggleIcon', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$2 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonSelect),\n  multi: true\n};\nlet IonSelect = /*#__PURE__*/(() => {\n  let IonSelect = class IonSelect extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionDismiss', 'ionFocus', 'ionBlur']);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonSelect_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonSelect)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonSelect,\n      selectors: [[\"ion-select\"]],\n      hostBindings: function IonSelect_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonSelect_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        cancelText: \"cancelText\",\n        color: \"color\",\n        compareWith: \"compareWith\",\n        disabled: \"disabled\",\n        errorText: \"errorText\",\n        expandedIcon: \"expandedIcon\",\n        fill: \"fill\",\n        helperText: \"helperText\",\n        interface: \"interface\",\n        interfaceOptions: \"interfaceOptions\",\n        justify: \"justify\",\n        label: \"label\",\n        labelPlacement: \"labelPlacement\",\n        mode: \"mode\",\n        multiple: \"multiple\",\n        name: \"name\",\n        okText: \"okText\",\n        placeholder: \"placeholder\",\n        selectedText: \"selectedText\",\n        shape: \"shape\",\n        toggleIcon: \"toggleIcon\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$2]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonSelect_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonSelect = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1p,\n    inputs: SELECT_INPUTS,\n    methods: ['open']\n  })], IonSelect);\n  return IonSelect;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TEXTAREA_INPUTS = ['autoGrow', 'autocapitalize', 'autofocus', 'clearOnEdit', 'color', 'cols', 'counter', 'counterFormatter', 'debounce', 'disabled', 'enterkeyhint', 'errorText', 'fill', 'helperText', 'inputmode', 'label', 'labelPlacement', 'maxlength', 'minlength', 'mode', 'name', 'placeholder', 'readonly', 'required', 'rows', 'shape', 'spellcheck', 'value', 'wrap'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider$1 = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonTextarea),\n  multi: true\n};\nlet IonTextarea = /*#__PURE__*/(() => {\n  let IonTextarea = class IonTextarea extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);\n    }\n    handleIonInput(el) {\n      this.handleValueChange(el, el.value);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonTextarea_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonTextarea)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonTextarea,\n      selectors: [[\"ion-textarea\"]],\n      hostBindings: function IonTextarea_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionInput\", function IonTextarea_ionInput_HostBindingHandler($event) {\n            return ctx.handleIonInput($event.target);\n          });\n        }\n      },\n      inputs: {\n        autoGrow: \"autoGrow\",\n        autocapitalize: \"autocapitalize\",\n        autofocus: \"autofocus\",\n        clearOnEdit: \"clearOnEdit\",\n        color: \"color\",\n        cols: \"cols\",\n        counter: \"counter\",\n        counterFormatter: \"counterFormatter\",\n        debounce: \"debounce\",\n        disabled: \"disabled\",\n        enterkeyhint: \"enterkeyhint\",\n        errorText: \"errorText\",\n        fill: \"fill\",\n        helperText: \"helperText\",\n        inputmode: \"inputmode\",\n        label: \"label\",\n        labelPlacement: \"labelPlacement\",\n        maxlength: \"maxlength\",\n        minlength: \"minlength\",\n        mode: \"mode\",\n        name: \"name\",\n        placeholder: \"placeholder\",\n        readonly: \"readonly\",\n        required: \"required\",\n        rows: \"rows\",\n        shape: \"shape\",\n        spellcheck: \"spellcheck\",\n        value: \"value\",\n        wrap: \"wrap\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider$1]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonTextarea_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonTextarea = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1q,\n    inputs: TEXTAREA_INPUTS,\n    methods: ['setFocus', 'getInputElement']\n  })], IonTextarea);\n  return IonTextarea;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst TOGGLE_INPUTS = ['checked', 'color', 'disabled', 'enableOnOffLabels', 'errorText', 'helperText', 'justify', 'labelPlacement', 'mode', 'name', 'value'];\n/**\n * Pulling the provider into an object and using PURE works\n * around an ng-packagr issue that causes\n * components with multiple decorators and\n * a provider to be re-assigned. This re-assignment\n * is not supported by Webpack and causes treeshaking\n * to not work on these kinds of components.\n */\nconst accessorProvider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*@__PURE__*/forwardRef(() => IonToggle),\n  multi: true\n};\nlet IonToggle = /*#__PURE__*/(() => {\n  let IonToggle = class IonToggle extends ValueAccessor {\n    z;\n    el;\n    constructor(c, r, z, injector) {\n      super(injector, r);\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);\n    }\n    writeValue(value) {\n      this.elementRef.nativeElement.checked = this.lastValue = value;\n      setIonicClasses(this.elementRef);\n    }\n    handleIonChange(el) {\n      this.handleValueChange(el, el.checked);\n    }\n    /** @nocollapse */\n    static ɵfac = function IonToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IonToggle)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Injector));\n    };\n    /** @nocollapse */\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: IonToggle,\n      selectors: [[\"ion-toggle\"]],\n      hostBindings: function IonToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"ionChange\", function IonToggle_ionChange_HostBindingHandler($event) {\n            return ctx.handleIonChange($event.target);\n          });\n        }\n      },\n      inputs: {\n        checked: \"checked\",\n        color: \"color\",\n        disabled: \"disabled\",\n        enableOnOffLabels: \"enableOnOffLabels\",\n        errorText: \"errorText\",\n        helperText: \"helperText\",\n        justify: \"justify\",\n        labelPlacement: \"labelPlacement\",\n        mode: \"mode\",\n        name: \"name\",\n        value: \"value\"\n      },\n      features: [i0.ɵɵProvidersFeature([accessorProvider]), i0.ɵɵInheritDefinitionFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      template: function IonToggle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  };\n  IonToggle = __decorate([ProxyCmp({\n    defineCustomElementFn: defineCustomElement$1r,\n    inputs: TOGGLE_INPUTS\n  })], IonToggle);\n  return IonToggle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActionSheetController, AlertController, AnimationController, GestureController, IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonDatetimeButton, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonInputOtp, IonInputPasswordToggle, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPicker, IonPickerColumn, IonPickerColumnOption, IonPickerLegacy, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterLink, IonRouterLinkWithHref, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSegmentContent, IonSegmentView, IonSelect, IonSelectModal, IonSelectOption, IonSkeletonText, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, LoadingController, MenuController, ModalController, PickerController, PopoverController, ToastController, provideIonicAngular };\n//# sourceMappingURL=ionic-angular-standalone.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}