{"ast":null,"code":"/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';\nimport { p as printIonWarning } from './index4.js';\nimport { c as createColorClasses } from './theme.js';\nimport { l as eyeOff, m as eye } from './index6.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { d as defineCustomElement$4 } from './button.js';\nimport { d as defineCustomElement$3 } from './icon.js';\nimport { d as defineCustomElement$2 } from './ripple-effect.js';\nconst iosInputPasswordToggleCss = \"\";\nconst mdInputPasswordToggleCss = \"\";\nconst InputPasswordToggle = /*@__PURE__*/proxyCustomElement(class InputPasswordToggle extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    /**\n     * @internal\n     */\n    this.type = 'password';\n    this.togglePasswordVisibility = () => {\n      const {\n        inputElRef\n      } = this;\n      if (!inputElRef) {\n        return;\n      }\n      inputElRef.type = inputElRef.type === 'text' ? 'password' : 'text';\n    };\n  }\n  /**\n   * Whenever the input type changes we need to re-run validation to ensure the password\n   * toggle is being used with the correct input type. If the application changes the type\n   * outside of this component we also need to re-render so the correct icon is shown.\n   */\n  onTypeChange(newValue) {\n    if (newValue !== 'text' && newValue !== 'password') {\n      printIonWarning(`[ion-input-password-toggle] - Only inputs of type \"text\" or \"password\" are supported. Input of type \"${newValue}\" is not compatible.`, this.el);\n      return;\n    }\n  }\n  connectedCallback() {\n    const {\n      el\n    } = this;\n    const inputElRef = this.inputElRef = el.closest('ion-input');\n    if (!inputElRef) {\n      printIonWarning('[ion-input-password-toggle] - No ancestor ion-input found. This component must be slotted inside of an ion-input.', el);\n      return;\n    }\n    /**\n     * Important: Set the type in connectedCallback because the default value\n     * of this.type may not always be accurate. Usually inputs have the \"password\" type\n     * but it is possible to have the input to initially have the \"text\" type. In that scenario\n     * the wrong icon will show briefly before switching to the correct icon. Setting the\n     * type here allows us to avoid that flicker.\n     */\n    this.type = inputElRef.type;\n  }\n  disconnectedCallback() {\n    this.inputElRef = null;\n  }\n  render() {\n    var _a, _b;\n    const {\n      color,\n      type\n    } = this;\n    const mode = getIonMode(this);\n    const showPasswordIcon = (_a = this.showIcon) !== null && _a !== void 0 ? _a : eye;\n    const hidePasswordIcon = (_b = this.hideIcon) !== null && _b !== void 0 ? _b : eyeOff;\n    const isPasswordVisible = type === 'text';\n    return h(Host, {\n      key: '91bc55664d496fe457518bd112865dd7811d0c17',\n      class: createColorClasses(color, {\n        [mode]: true\n      })\n    }, h(\"ion-button\", {\n      key: 'f3e436422110c9cb4d5c0b83500255b24ab4cdef',\n      mode: mode,\n      color: color,\n      fill: \"clear\",\n      shape: \"round\",\n      \"aria-checked\": isPasswordVisible ? 'true' : 'false',\n      \"aria-label\": isPasswordVisible ? 'Hide password' : 'Show password',\n      role: \"switch\",\n      type: \"button\",\n      onPointerDown: ev => {\n        /**\n         * This prevents mobile browsers from\n         * blurring the input when the password toggle\n         * button is activated.\n         */\n        ev.preventDefault();\n      },\n      onClick: this.togglePasswordVisibility\n    }, h(\"ion-icon\", {\n      key: '5c8b121153f148f92aa7cba0447673a4f6f3ad1e',\n      slot: \"icon-only\",\n      \"aria-hidden\": \"true\",\n      icon: isPasswordVisible ? hidePasswordIcon : showPasswordIcon\n    })));\n  }\n  get el() {\n    return this;\n  }\n  static get watchers() {\n    return {\n      \"type\": [\"onTypeChange\"]\n    };\n  }\n  static get style() {\n    return {\n      ios: iosInputPasswordToggleCss,\n      md: mdInputPasswordToggleCss\n    };\n  }\n}, [289, \"ion-input-password-toggle\", {\n  \"color\": [513],\n  \"showIcon\": [1, \"show-icon\"],\n  \"hideIcon\": [1, \"hide-icon\"],\n  \"type\": [1025]\n}, undefined, {\n  \"type\": [\"onTypeChange\"]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-input-password-toggle\", \"ion-button\", \"ion-icon\", \"ion-ripple-effect\"];\n  components.forEach(tagName => {\n    switch (tagName) {\n      case \"ion-input-password-toggle\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, InputPasswordToggle);\n        }\n        break;\n      case \"ion-button\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$4();\n        }\n        break;\n      case \"ion-icon\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$3();\n        }\n        break;\n      case \"ion-ripple-effect\":\n        if (!customElements.get(tagName)) {\n          defineCustomElement$2();\n        }\n        break;\n    }\n  });\n}\nconst IonInputPasswordToggle = InputPasswordToggle;\nconst defineCustomElement = defineCustomElement$1;\nexport { IonInputPasswordToggle, defineCustomElement };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}