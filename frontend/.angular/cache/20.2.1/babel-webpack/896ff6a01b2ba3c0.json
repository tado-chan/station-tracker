{"ast":null,"code":"import _asyncToGenerator from \"/mnt/c/Users/aluta/station-tracker/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { debounceTime, filter } from 'rxjs/operators';\nimport { GeofenceManagerService } from './geofence-manager.service';\nimport { GeofenceOptimizerService } from './geofence-optimizer.service';\nimport { CloudSyncService } from './cloud-sync.service';\nimport { StationService } from '../app/services/station.service';\nimport BackgroundGeofence from '../plugins/background-geofence';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./geofence-manager.service\";\nimport * as i2 from \"./geofence-optimizer.service\";\nimport * as i3 from \"./cloud-sync.service\";\nimport * as i4 from \"../app/services/station.service\";\nexport let IntegratedGeofenceService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class IntegratedGeofenceService {\n    constructor(geofenceManager, optimizer, cloudSync, stationService) {\n      this.geofenceManager = geofenceManager;\n      this.optimizer = optimizer;\n      this.cloudSync = cloudSync;\n      this.stationService = stationService;\n      this.trackingStatus = new BehaviorSubject({\n        isActive: false,\n        nativeGeofencing: false,\n        jsGeofencing: false,\n        backgroundMode: false,\n        cloudSync: false,\n        activeRegions: 0,\n        lastLocationUpdate: null,\n        batteryOptimized: true\n      });\n      this.configuration = {\n        useNativeGeofencing: true,\n        useFallbackJS: true,\n        enableCloudSync: true,\n        optimizationLevel: 'balanced',\n        syncInterval: 30000,\n        maxRegions: 20 // Default for iOS\n      };\n      this.subscriptions = [];\n      this.stations = [];\n      this.isInitialized = false;\n      this.setupSubscriptions();\n      this.loadConfiguration();\n    }\n    /**\n     * Initialize the integrated geofence system\n     */\n    initialize() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (_this.isInitialized) return;\n        try {\n          console.log('Initializing integrated geofence system...');\n          // Load stations\n          _this.stations = (yield _this.stationService.getAllStations().toPromise()) || [];\n          console.log(`Loaded ${_this.stations.length} stations`);\n          // Initialize geofence manager\n          yield _this.geofenceManager.initialize(_this.stations);\n          // Setup native plugin listeners\n          _this.setupNativeListeners();\n          // Update configuration based on device capabilities\n          yield _this.updateConfigurationForDevice();\n          _this.isInitialized = true;\n          console.log('Integrated geofence system initialized successfully');\n        } catch (error) {\n          console.error('Failed to initialize integrated geofence system:', error);\n          throw error;\n        }\n      })();\n    }\n    /**\n     * Start integrated tracking\n     */\n    startTracking() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.isInitialized) {\n          yield _this2.initialize();\n        }\n        try {\n          console.log('Starting integrated geofence tracking...');\n          let nativeSuccess = false;\n          let jsSuccess = false;\n          // Try native geofencing first\n          if (_this2.configuration.useNativeGeofencing) {\n            try {\n              const permissions = yield BackgroundGeofence.checkPermissions();\n              if (permissions.backgroundLocation === 'granted') {\n                yield BackgroundGeofence.startGeofencing({\n                  enableHighAccuracy: _this2.configuration.optimizationLevel === 'accuracy',\n                  notification: {\n                    title: '駅記録アプリ',\n                    text: 'バックグラウンドで駅への到着・出発を記録中...'\n                  },\n                  distanceFilter: _this2.getDistanceFilterForOptimization(),\n                  interval: _this2.configuration.syncInterval\n                });\n                nativeSuccess = true;\n                console.log('Native geofencing started successfully');\n              } else {\n                console.warn('Background location permission not granted, requesting...');\n                const requested = yield BackgroundGeofence.requestPermissions();\n                if (requested.backgroundLocation === 'granted') {\n                  yield BackgroundGeofence.startGeofencing({\n                    enableHighAccuracy: _this2.configuration.optimizationLevel === 'accuracy',\n                    notification: {\n                      title: '駅記録アプリ',\n                      text: 'バックグラウンドで駅への到着・出発を記録中...'\n                    }\n                  });\n                  nativeSuccess = true;\n                }\n              }\n            } catch (error) {\n              console.error('Native geofencing failed to start:', error);\n            }\n          }\n          // Fallback to JS geofencing if native failed and fallback enabled\n          if (!nativeSuccess && _this2.configuration.useFallbackJS) {\n            // Implement JS-based geofencing as fallback\n            jsSuccess = yield _this2.startJSGeofencing();\n          }\n          const trackingStarted = nativeSuccess || jsSuccess;\n          _this2.updateTrackingStatus({\n            isActive: trackingStarted,\n            nativeGeofencing: nativeSuccess,\n            jsGeofencing: jsSuccess,\n            backgroundMode: nativeSuccess,\n            // Native geofencing includes background mode\n            cloudSync: _this2.configuration.enableCloudSync\n          });\n          if (trackingStarted) {\n            // Report analytics\n            yield _this2.cloudSync.reportAnalytics('tracking_started', {\n              native: nativeSuccess,\n              fallback: jsSuccess,\n              configuration: _this2.configuration\n            });\n          }\n          return trackingStarted;\n        } catch (error) {\n          console.error('Failed to start integrated tracking:', error);\n          _this2.updateTrackingStatus({\n            isActive: false\n          });\n          return false;\n        }\n      })();\n    }\n    /**\n     * Stop all tracking\n     */\n    stopTracking() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log('Stopping integrated geofence tracking...');\n          // Stop native geofencing\n          if (_this3.trackingStatus.value.nativeGeofencing) {\n            yield BackgroundGeofence.stopGeofencing();\n          }\n          // Stop JS geofencing\n          if (_this3.trackingStatus.value.jsGeofencing) {\n            yield _this3.stopJSGeofencing();\n          }\n          _this3.updateTrackingStatus({\n            isActive: false,\n            nativeGeofencing: false,\n            jsGeofencing: false,\n            backgroundMode: false,\n            activeRegions: 0\n          });\n          // Report analytics\n          yield _this3.cloudSync.reportAnalytics('tracking_stopped', {\n            reason: 'user_requested'\n          });\n        } catch (error) {\n          console.error('Failed to stop tracking:', error);\n        }\n      })();\n    }\n    /**\n     * Update location and optimize geofences\n     */\n    updateLocation(_x, _x2) {\n      var _this4 = this;\n      return _asyncToGenerator(function* (latitude, longitude, accuracy = 10) {\n        if (!_this4.isInitialized) return;\n        const location = {\n          latitude,\n          longitude,\n          accuracy,\n          timestamp: new Date()\n        };\n        // Update optimizer with new location\n        _this4.optimizer.updateLocation(location);\n        // Update geofence manager\n        yield _this4.geofenceManager.updateLocation(latitude, longitude);\n        _this4.updateTrackingStatus({\n          lastLocationUpdate: new Date()\n        });\n      }).apply(this, arguments);\n    }\n    /**\n     * Setup native plugin listeners\n     */\n    setupNativeListeners() {\n      var _this5 = this;\n      // Listen for geofence events\n      BackgroundGeofence.addListener('geofenceEvent', /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (event) {\n          console.log('Native geofence event received:', event);\n          // Process the event\n          yield _this5.handleGeofenceEvent(event);\n          // Queue for cloud sync if enabled\n          if (_this5.configuration.enableCloudSync) {\n            yield _this5.cloudSync.queueGeofenceEvent(event);\n          }\n        });\n        return function (_x3) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      // Listen for location updates\n      BackgroundGeofence.addListener('locationUpdate', location => {\n        this.updateLocation(location.latitude, location.longitude, location.accuracy);\n      });\n    }\n    /**\n     * Setup service subscriptions\n     */\n    setupSubscriptions() {\n      // Monitor geofence statistics\n      this.subscriptions.push(this.geofenceManager.getStats().subscribe(stats => {\n        this.updateTrackingStatus({\n          activeRegions: stats.activeRegions,\n          batteryOptimized: stats.activeRegions <= stats.maxRegions\n        });\n      }));\n      // Monitor cloud sync status\n      this.subscriptions.push(this.cloudSync.getSyncStatus().subscribe(status => {\n        this.updateTrackingStatus({\n          cloudSync: status.isOnline && status.syncErrors < 5\n        });\n      }));\n      // Auto-optimization based on movement patterns\n      this.subscriptions.push(combineLatest([this.geofenceManager.getCurrentLocation(), this.optimizer.getMovementPattern()]).pipe(filter(([location, pattern]) => location !== null), debounceTime(30000) // 30 second debounce\n      ).subscribe(([location, pattern]) => {\n        if (location && this.trackingStatus.value.isActive) {\n          this.performIntelligentOptimization(location, pattern);\n        }\n      }));\n    }\n    /**\n     * Perform intelligent optimization based on movement patterns\n     */\n    performIntelligentOptimization(location, pattern) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (_this6.configuration.optimizationLevel === 'battery' && pattern) {\n            // Reduce geofence count when stationary\n            if (pattern.averageSpeed < 1) {\n              // Very stationary - use fewer, closer regions\n              yield _this6.geofenceManager.updateLocation(location.latitude, location.longitude);\n            } else if (pattern.averageSpeed > 20) {\n              // High speed movement - use larger, fewer regions\n              const currentStats = yield _this6.geofenceManager.getStats().pipe().toPromise();\n              if (currentStats && currentStats.activeRegions > 10) {\n                yield _this6.geofenceManager.forceOptimization();\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Intelligent optimization failed:', error);\n        }\n      })();\n    }\n    /**\n     * Handle geofence events from any source\n     */\n    handleGeofenceEvent(event) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log('Processing geofence event:', event);\n          // Find the station\n          const stationId = event.data?.stationId;\n          const station = _this7.stations.find(s => s.id === stationId);\n          if (station && event.action === 'enter') {\n            // Record station visit\n            const visit = {\n              station: station.id,\n              arrived_at: new Date(event.timestamp).toISOString(),\n              latitude: event.latitude,\n              longitude: event.longitude,\n              weather: yield _this7.getCurrentWeather({\n                latitude: event.latitude,\n                longitude: event.longitude\n              })\n            };\n            try {\n              yield _this7.stationService.createVisit(visit).toPromise();\n              console.log(`Recorded visit to ${station.name}`);\n              // Sync visit to cloud if enabled\n              if (_this7.configuration.enableCloudSync) {\n                yield _this7.cloudSync.syncStationVisit(visit);\n              }\n            } catch (error) {\n              console.error('Failed to record station visit:', error);\n            }\n          }\n          // Report analytics\n          yield _this7.cloudSync.reportAnalytics('geofence_event', {\n            stationId,\n            stationName: station?.name,\n            eventType: event.action,\n            source: 'native'\n          });\n        } catch (error) {\n          console.error('Failed to handle geofence event:', error);\n        }\n      })();\n    }\n    /**\n     * Fallback JS geofencing (simplified)\n     */\n    startJSGeofencing() {\n      return _asyncToGenerator(function* () {\n        // This would be a simplified JS implementation for when native fails\n        console.log('Starting JS fallback geofencing...');\n        // Implementation would use regular geolocation API with setInterval\n        return true; // Placeholder\n      })();\n    }\n    stopJSGeofencing() {\n      return _asyncToGenerator(function* () {\n        console.log('Stopping JS fallback geofencing...');\n        // Stop JS-based tracking\n      })();\n    }\n    /**\n     * Update device-specific configuration\n     */\n    updateConfigurationForDevice() {\n      var _this8 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Detect platform capabilities\n          const permissions = yield BackgroundGeofence.checkPermissions();\n          // Adjust max regions based on platform\n          // iOS: 20 regions, Android: 100 regions\n          // This would be detected via Capacitor.getPlatform() in real implementation\n          _this8.configuration.maxRegions = 20; // Assume iOS for now\n          // Adjust optimization level based on permissions\n          if (permissions.backgroundLocation !== 'granted') {\n            _this8.configuration.optimizationLevel = 'battery';\n            _this8.configuration.useNativeGeofencing = false;\n          }\n          console.log('Updated configuration for device:', _this8.configuration);\n        } catch (error) {\n          console.error('Failed to update device configuration:', error);\n        }\n      })();\n    }\n    /**\n     * Get distance filter based on optimization level\n     */\n    getDistanceFilterForOptimization() {\n      switch (this.configuration.optimizationLevel) {\n        case 'accuracy':\n          return 5;\n        // 5 meters\n        case 'balanced':\n          return 10;\n        // 10 meters\n        case 'battery':\n          return 25;\n        // 25 meters\n        default:\n          return 10;\n      }\n    }\n    /**\n     * Get current weather (mock implementation)\n     */\n    getCurrentWeather(location) {\n      return _asyncToGenerator(function* () {\n        const weatherTypes = ['晴れ', '曇り', '雨', '雪'];\n        return weatherTypes[Math.floor(Math.random() * weatherTypes.length)];\n      })();\n    }\n    /**\n     * Load configuration from storage\n     */\n    loadConfiguration() {\n      try {\n        const stored = localStorage.getItem('tracking_configuration');\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          this.configuration = {\n            ...this.configuration,\n            ...parsed\n          };\n          console.log('Loaded tracking configuration:', this.configuration);\n        }\n      } catch (error) {\n        console.error('Failed to load configuration:', error);\n      }\n    }\n    /**\n     * Save configuration to storage\n     */\n    saveConfiguration() {\n      try {\n        localStorage.setItem('tracking_configuration', JSON.stringify(this.configuration));\n      } catch (error) {\n        console.error('Failed to save configuration:', error);\n      }\n    }\n    /**\n     * Update tracking status\n     */\n    updateTrackingStatus(updates) {\n      const current = this.trackingStatus.value;\n      this.trackingStatus.next({\n        ...current,\n        ...updates\n      });\n    }\n    // Public API methods\n    getTrackingStatus() {\n      return this.trackingStatus.asObservable();\n    }\n    getCurrentConfiguration() {\n      return {\n        ...this.configuration\n      };\n    }\n    updateConfiguration(updates) {\n      var _this9 = this;\n      return _asyncToGenerator(function* () {\n        _this9.configuration = {\n          ..._this9.configuration,\n          ...updates\n        };\n        _this9.saveConfiguration();\n        // Restart tracking with new configuration if currently active\n        if (_this9.trackingStatus.value.isActive) {\n          yield _this9.stopTracking();\n          yield _this9.startTracking();\n        }\n      })();\n    }\n    getSystemStatus() {\n      var _this0 = this;\n      return _asyncToGenerator(function* () {\n        const geofenceStats = yield _this0.geofenceManager.getStats().pipe().toPromise();\n        const syncStatus = _this0.cloudSync.getSyncStats();\n        const optimizationMetrics = yield _this0.optimizer.getOptimizationMetrics().pipe().toPromise();\n        return {\n          tracking: _this0.trackingStatus.value,\n          configuration: _this0.configuration,\n          geofence: geofenceStats,\n          sync: syncStatus,\n          optimization: optimizationMetrics\n        };\n      })();\n    }\n    // Cleanup\n    ngOnDestroy() {\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n      this.optimizer.destroy();\n      this.cloudSync.destroy();\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function IntegratedGeofenceService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || IntegratedGeofenceService)(i0.ɵɵinject(i1.GeofenceManagerService), i0.ɵɵinject(i2.GeofenceOptimizerService), i0.ɵɵinject(i3.CloudSyncService), i0.ɵɵinject(i4.StationService));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: IntegratedGeofenceService,\n      factory: IntegratedGeofenceService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return IntegratedGeofenceService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}