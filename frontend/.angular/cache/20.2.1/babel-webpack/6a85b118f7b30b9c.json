{"ast":null,"code":"import { BehaviorSubject, interval } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let GeofenceOptimizerService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GeofenceOptimizerService {\n    constructor() {\n      this.locationHistory = [];\n      this.movementPattern = new BehaviorSubject(null);\n      this.optimizationMetrics = new BehaviorSubject({\n        hitRate: 0,\n        falsePositiveRate: 0,\n        batteryScore: 100,\n        regionCount: 0,\n        lastOptimization: new Date()\n      });\n      this.MAX_LOCATION_HISTORY = 1000;\n      this.OPTIMIZATION_INTERVAL = 5 * 60 * 1000; // 5 minutes\n      this.loadLocationHistory();\n      this.startPeriodicOptimization();\n    }\n    /**\n     * Add new location to history and trigger analysis\n     */\n    updateLocation(location) {\n      this.locationHistory.unshift(location);\n      // Keep history within limits\n      if (this.locationHistory.length > this.MAX_LOCATION_HISTORY) {\n        this.locationHistory = this.locationHistory.slice(0, this.MAX_LOCATION_HISTORY);\n      }\n      this.saveLocationHistory();\n      this.analyzeMovementPattern();\n    }\n    /**\n     * Analyze movement patterns from location history\n     */\n    analyzeMovementPattern() {\n      if (this.locationHistory.length < 10) return;\n      const recentLocations = this.locationHistory.slice(0, 50); // Last 50 locations\n      // Calculate average speed\n      let totalSpeed = 0;\n      let speedSamples = 0;\n      for (let i = 1; i < recentLocations.length; i++) {\n        const current = recentLocations[i - 1];\n        const previous = recentLocations[i];\n        const distance = this.calculateDistance(current.latitude, current.longitude, previous.latitude, previous.longitude);\n        const timeDiff = (current.timestamp.getTime() - previous.timestamp.getTime()) / 1000; // seconds\n        if (timeDiff > 0 && timeDiff < 600) {\n          // Within 10 minutes\n          const speed = distance / timeDiff; // m/s\n          if (speed < 50) {\n            // Filter out unrealistic speeds\n            totalSpeed += speed;\n            speedSamples++;\n          }\n        }\n      }\n      const averageSpeed = speedSamples > 0 ? totalSpeed / speedSamples : 0;\n      // Calculate primary direction\n      const primaryDirection = this.calculatePrimaryDirection(recentLocations);\n      // Find frequent areas\n      const frequentAreas = this.findFrequentAreas(this.locationHistory);\n      // Determine time context\n      const now = new Date();\n      const hour = now.getHours();\n      const timeOfDay = hour < 6 ? 'night' : hour < 12 ? 'morning' : hour < 18 ? 'afternoon' : 'evening';\n      const dayOfWeek = now.getDay();\n      const dayType = dayOfWeek === 0 || dayOfWeek === 6 ? 'weekend' : 'weekday';\n      const pattern = {\n        averageSpeed,\n        primaryDirection,\n        frequentAreas,\n        timeOfDay,\n        dayType\n      };\n      this.movementPattern.next(pattern);\n    }\n    /**\n     * Calculate primary direction of movement\n     */\n    calculatePrimaryDirection(locations) {\n      if (locations.length < 5) return 0;\n      let totalDeltaLat = 0;\n      let totalDeltaLng = 0;\n      for (let i = 1; i < Math.min(locations.length, 20); i++) {\n        totalDeltaLat += locations[i - 1].latitude - locations[i].latitude;\n        totalDeltaLng += locations[i - 1].longitude - locations[i].longitude;\n      }\n      const angle = Math.atan2(totalDeltaLat, totalDeltaLng) * 180 / Math.PI;\n      return (angle + 360) % 360; // Normalize to 0-360 degrees\n    }\n    /**\n     * Find frequently visited areas\n     */\n    findFrequentAreas(locations) {\n      const gridSize = 0.001; // ~100m grid\n      const areaMap = new Map();\n      for (const location of locations) {\n        const gridLat = Math.round(location.latitude / gridSize) * gridSize;\n        const gridLng = Math.round(location.longitude / gridSize) * gridSize;\n        const key = `${gridLat},${gridLng}`;\n        if (areaMap.has(key)) {\n          areaMap.get(key).visits++;\n        } else {\n          areaMap.set(key, {\n            lat: gridLat,\n            lng: gridLng,\n            visits: 1\n          });\n        }\n      }\n      return Array.from(areaMap.values()).filter(area => area.visits >= 5).sort((a, b) => b.visits - a.visits).slice(0, 10); // Top 10 frequent areas\n    }\n    /**\n     * Optimize geofence selection based on movement patterns and context\n     */\n    optimizeGeofenceSelection(nearbyStations, currentLocation, maxRegions) {\n      const pattern = this.movementPattern.value;\n      const optimizedStations = nearbyStations.map(item => ({\n        ...item,\n        score: this.calculateStationScore(item, currentLocation, pattern)\n      })).sort((a, b) => b.score - a.score);\n      // Apply context-based filtering\n      const contextFiltered = this.applyContextFiltering(optimizedStations, pattern);\n      // Select top stations within limits\n      const selected = contextFiltered.slice(0, maxRegions);\n      // Create optimized geofence regions\n      return selected.map((item, index) => {\n        const radius = this.calculateDynamicRadius(item, pattern);\n        return {\n          identifier: `station-${item.station.id}`,\n          latitude: item.station.latitude,\n          longitude: item.station.longitude,\n          radius,\n          notifyOnEntry: true,\n          notifyOnExit: true,\n          data: {\n            stationId: item.station.id,\n            stationName: item.station.name,\n            line: item.station.line,\n            score: item.score,\n            optimized: true\n          },\n          station: item.station,\n          priority: Math.round(item.score),\n          lastUpdated: new Date(),\n          distanceFromUser: item.distance\n        };\n      });\n    }\n    /**\n     * Calculate station score based on multiple factors\n     */\n    calculateStationScore(item, currentLocation, pattern) {\n      let score = 0;\n      // Base distance score (closer = higher)\n      const maxDistance = 10000; // 10km\n      const distanceScore = Math.max(0, (maxDistance - item.distance) / maxDistance * 100);\n      score += distanceScore * 0.4; // 40% weight\n      // Movement direction alignment\n      if (pattern) {\n        const directionToStation = this.calculateBearing(currentLocation.latitude, currentLocation.longitude, item.station.latitude, item.station.longitude);\n        const directionDiff = Math.abs(directionToStation - pattern.primaryDirection);\n        const alignmentScore = Math.max(0, (180 - Math.min(directionDiff, 360 - directionDiff)) / 180 * 100);\n        score += alignmentScore * 0.2; // 20% weight\n      }\n      // Frequent area proximity\n      if (pattern && pattern.frequentAreas.length > 0) {\n        const nearFrequentArea = pattern.frequentAreas.some(area => {\n          const distToArea = this.calculateDistance(item.station.latitude, item.station.longitude, area.lat, area.lng);\n          return distToArea <= 500; // Within 500m of frequent area\n        });\n        if (nearFrequentArea) {\n          score += 30; // Bonus for frequent areas\n        }\n      }\n      // Line importance (major lines get bonus)\n      const line = item.station.line?.toLowerCase() || '';\n      if (line.includes('山手') || line.includes('yamanote')) score += 25;else if (line.includes('中央') || line.includes('総武')) score += 20;else if (line.includes('京浜東北')) score += 15;else if (line.includes('東海道')) score += 10;\n      // Time-based context\n      if (pattern) {\n        // Morning/evening rush hours - prioritize major stations\n        if ((pattern.timeOfDay === 'morning' || pattern.timeOfDay === 'evening') && pattern.dayType === 'weekday') {\n          const stationName = item.station.name?.toLowerCase() || '';\n          if (stationName.includes('新宿') || stationName.includes('東京') || stationName.includes('渋谷') || stationName.includes('品川')) {\n            score += 20;\n          }\n        }\n      }\n      // Speed-based radius adjustment factor\n      if (pattern && pattern.averageSpeed > 10) {\n        // Moving fast (>36 km/h)\n        score += 10; // Prioritize when moving fast\n      }\n      return Math.round(score);\n    }\n    /**\n     * Apply context-based filtering\n     */\n    applyContextFiltering(stations, pattern) {\n      if (!pattern) return stations;\n      // Filter based on movement speed\n      if (pattern.averageSpeed > 20) {\n        // High speed (>72 km/h) - likely in vehicle\n        // Prioritize major stations and reduce total count for better performance\n        return stations.filter(s => s.score >= 50).slice(0, Math.floor(stations.length * 0.7));\n      }\n      if (pattern.averageSpeed < 2) {\n        // Very low speed - likely stationary\n        // Focus on very close stations\n        return stations.filter(s => s.distance <= 2000);\n      }\n      // Weekend vs weekday filtering\n      if (pattern.dayType === 'weekend') {\n        // On weekends, focus more on leisure/shopping areas\n        // This would need station category data to implement properly\n      }\n      return stations;\n    }\n    /**\n     * Calculate dynamic radius based on context\n     */\n    calculateDynamicRadius(item, pattern) {\n      let baseRadius = 100; // Base 100m radius\n      // Adjust based on distance\n      if (item.distance > 5000) baseRadius = 150;else if (item.distance > 2000) baseRadius = 120;else if (item.distance < 500) baseRadius = 80;\n      // Adjust based on movement speed\n      if (pattern) {\n        if (pattern.averageSpeed > 15) {\n          // Fast movement\n          baseRadius += 50; // Larger radius for better detection\n        } else if (pattern.averageSpeed < 1) {\n          // Stationary\n          baseRadius -= 20; // Smaller radius to avoid false positives\n        }\n      }\n      // Try to use polygon data for precision\n      try {\n        const polygon = JSON.parse(item.station.polygon_data);\n        if (polygon.type === 'Polygon' && polygon.coordinates && polygon.coordinates[0]) {\n          const coords = polygon.coordinates[0];\n          let minLat = coords[0][1],\n            maxLat = coords[0][1];\n          let minLng = coords[0][0],\n            maxLng = coords[0][0];\n          for (const coord of coords) {\n            minLat = Math.min(minLat, coord[1]);\n            maxLat = Math.max(maxLat, coord[1]);\n            minLng = Math.min(minLng, coord[0]);\n            maxLng = Math.max(maxLng, coord[0]);\n          }\n          const latDistance = this.calculateDistance(minLat, item.station.longitude, maxLat, item.station.longitude);\n          const lngDistance = this.calculateDistance(item.station.latitude, minLng, item.station.latitude, maxLng);\n          const polygonRadius = Math.max(latDistance, lngDistance) / 2;\n          baseRadius = Math.max(baseRadius, polygonRadius + 30);\n        }\n      } catch (error) {\n        // Use calculated base radius\n      }\n      return Math.max(baseRadius, 50); // Minimum 50m\n    }\n    /**\n     * Start periodic optimization\n     */\n    startPeriodicOptimization() {\n      this.optimizationSubscription = interval(this.OPTIMIZATION_INTERVAL).subscribe(() => {\n        this.analyzeMovementPattern();\n      });\n    }\n    /**\n     * Calculate bearing between two points\n     */\n    calculateBearing(lat1, lng1, lat2, lng2) {\n      const dLng = (lng2 - lng1) * Math.PI / 180;\n      const lat1Rad = lat1 * Math.PI / 180;\n      const lat2Rad = lat2 * Math.PI / 180;\n      const y = Math.sin(dLng) * Math.cos(lat2Rad);\n      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);\n      const bearing = Math.atan2(y, x) * 180 / Math.PI;\n      return (bearing + 360) % 360;\n    }\n    /**\n     * Calculate distance between coordinates\n     */\n    calculateDistance(lat1, lon1, lat2, lon2) {\n      const R = 6371e3;\n      const φ1 = lat1 * Math.PI / 180;\n      const φ2 = lat2 * Math.PI / 180;\n      const Δφ = (lat2 - lat1) * Math.PI / 180;\n      const Δλ = (lon2 - lon1) * Math.PI / 180;\n      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return R * c;\n    }\n    /**\n     * Save location history to storage\n     */\n    saveLocationHistory() {\n      try {\n        const recentHistory = this.locationHistory.slice(0, 200); // Save last 200 locations\n        const serializable = recentHistory.map(loc => ({\n          ...loc,\n          timestamp: loc.timestamp.toISOString()\n        }));\n        localStorage.setItem('location_history', JSON.stringify(serializable));\n      } catch (error) {\n        console.error('Failed to save location history:', error);\n      }\n    }\n    /**\n     * Load location history from storage\n     */\n    loadLocationHistory() {\n      try {\n        const stored = localStorage.getItem('location_history');\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          this.locationHistory = parsed.map(loc => ({\n            ...loc,\n            timestamp: new Date(loc.timestamp)\n          }));\n          console.log(`Loaded ${this.locationHistory.length} location history entries`);\n        }\n      } catch (error) {\n        console.error('Failed to load location history:', error);\n      }\n    }\n    // Observable getters\n    getMovementPattern() {\n      return this.movementPattern.asObservable();\n    }\n    getOptimizationMetrics() {\n      return this.optimizationMetrics.asObservable();\n    }\n    // Cleanup\n    destroy() {\n      if (this.optimizationSubscription) {\n        this.optimizationSubscription.unsubscribe();\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GeofenceOptimizerService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GeofenceOptimizerService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GeofenceOptimizerService,\n      factory: GeofenceOptimizerService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return GeofenceOptimizerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}