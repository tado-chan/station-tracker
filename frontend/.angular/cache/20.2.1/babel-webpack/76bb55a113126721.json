{"ast":null,"code":"import _asyncToGenerator from \"/mnt/c/Users/aluta/station-tracker/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport BackgroundGeofence from '../plugins/background-geofence';\nimport * as i0 from \"@angular/core\";\nexport let GeofenceManagerService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GeofenceManagerService {\n    constructor() {\n      // OS limits for geofence regions\n      this.MAX_ANDROID_REGIONS = 100;\n      this.MAX_IOS_REGIONS = 20;\n      this.OPTIMIZATION_RADIUS = 10000; // 10km\n      this.HIGH_PRIORITY_RADIUS = 2000; // 2km\n      this.MEDIUM_PRIORITY_RADIUS = 5000; // 5km\n      this.currentLocation = new BehaviorSubject(null);\n      this.activeRegions = new BehaviorSubject([]);\n      this.stats = new BehaviorSubject({\n        activeRegions: 0,\n        maxRegions: this.getMaxRegions(),\n        nearbyStations: 0,\n        totalStations: 0,\n        lastOptimization: null\n      });\n      this.allStations = [];\n      this.regionStorage = new Map();\n      this.loadStoredRegions();\n    }\n    initialize(stations) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.allStations = stations;\n        _this.updateStats({\n          totalStations: stations.length\n        });\n        console.log(`GeofenceManager initialized with ${stations.length} stations`);\n      })();\n    }\n    /**\n     * Update user location and optimize geofence regions\n     */\n    updateLocation(latitude, longitude) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const newLocation = {\n          latitude,\n          longitude\n        };\n        const previousLocation = _this2.currentLocation.value;\n        _this2.currentLocation.next(newLocation);\n        // Check if significant movement occurred\n        if (previousLocation) {\n          const distance = _this2.calculateDistance(previousLocation.latitude, previousLocation.longitude, latitude, longitude);\n          // Only optimize if moved more than 1km\n          if (distance < 1000) {\n            return;\n          }\n        }\n        yield _this2.optimizeGeofenceRegions(newLocation);\n      })();\n    }\n    /**\n     * Optimize geofence regions based on current location and OS limits\n     */\n    optimizeGeofenceRegions(location) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log('Optimizing geofence regions...');\n          // Find nearby stations within optimization radius\n          const nearbyStations = _this3.allStations.map(station => ({\n            station,\n            distance: _this3.calculateDistance(location.latitude, location.longitude, station.latitude, station.longitude)\n          })).filter(item => item.distance <= _this3.OPTIMIZATION_RADIUS).sort((a, b) => a.distance - b.distance);\n          _this3.updateStats({\n            nearbyStations: nearbyStations.length\n          });\n          // Prioritize stations\n          const prioritizedStations = _this3.prioritizeStations(nearbyStations, location);\n          // Select top stations within OS limits\n          const maxRegions = _this3.getMaxRegions();\n          const selectedStations = prioritizedStations.slice(0, maxRegions);\n          // Create geofence regions\n          const newRegions = selectedStations.map((item, index) => {\n            const station = item.station;\n            const radius = _this3.calculateOptimalRadius(station, item.distance);\n            return {\n              identifier: `station-${station.id}`,\n              latitude: station.latitude,\n              longitude: station.longitude,\n              radius,\n              notifyOnEntry: true,\n              notifyOnExit: true,\n              data: {\n                stationId: station.id,\n                stationName: station.name,\n                line: station.line,\n                priority: item.priority\n              },\n              station,\n              priority: item.priority,\n              lastUpdated: new Date(),\n              distanceFromUser: item.distance\n            };\n          });\n          // Update active regions\n          yield _this3.updateActiveRegions(newRegions);\n          _this3.updateStats({\n            activeRegions: newRegions.length,\n            lastOptimization: new Date()\n          });\n          console.log(`Optimized to ${newRegions.length} geofence regions`);\n        } catch (error) {\n          console.error('Failed to optimize geofence regions:', error);\n        }\n      })();\n    }\n    /**\n     * Prioritize stations based on distance, line importance, and user behavior\n     */\n    prioritizeStations(nearbyStations, location) {\n      return nearbyStations.map(item => {\n        let priority = 0;\n        const distance = item.distance;\n        // Distance-based priority (closer = higher priority)\n        if (distance <= 500) priority += 100; // Very close\n        else if (distance <= 1000) priority += 80;else if (distance <= 2000) priority += 60;else if (distance <= 5000) priority += 40;else priority += 20;\n        // Line-based priority (major lines get higher priority)\n        const line = item.station.line?.toLowerCase() || '';\n        if (line.includes('山手') || line.includes('yamanote')) priority += 30;else if (line.includes('中央') || line.includes('総武')) priority += 25;else if (line.includes('京浜東北')) priority += 20;else if (line.includes('東海道')) priority += 15;else priority += 10;\n        // Station type priority (major stations)\n        const stationName = item.station.name?.toLowerCase() || '';\n        if (stationName.includes('新宿') || stationName.includes('東京') || stationName.includes('渋谷') || stationName.includes('品川')) {\n          priority += 25;\n        }\n        // Direction-based priority (stations in direction of movement)\n        // This would require historical location data to implement properly\n        return {\n          ...item,\n          priority\n        };\n      }).sort((a, b) => b.priority - a.priority);\n    }\n    /**\n     * Calculate optimal radius for geofence based on station polygon or fallback\n     */\n    calculateOptimalRadius(station, distanceFromUser) {\n      try {\n        // Try to use polygon data if available\n        const polygon = JSON.parse(station.polygon_data);\n        if (polygon.type === 'Polygon' && polygon.coordinates && polygon.coordinates[0]) {\n          const coords = polygon.coordinates[0];\n          let minLat = coords[0][1],\n            maxLat = coords[0][1];\n          let minLng = coords[0][0],\n            maxLng = coords[0][0];\n          for (const coord of coords) {\n            minLat = Math.min(minLat, coord[1]);\n            maxLat = Math.max(maxLat, coord[1]);\n            minLng = Math.min(minLng, coord[0]);\n            maxLng = Math.max(maxLng, coord[0]);\n          }\n          const latDistance = this.calculateDistance(minLat, station.longitude, maxLat, station.longitude);\n          const lngDistance = this.calculateDistance(station.latitude, minLng, station.latitude, maxLng);\n          // Use polygon size + buffer\n          const polygonRadius = Math.max(latDistance, lngDistance) / 2;\n          return Math.max(polygonRadius + 30, 50); // Minimum 50m, add 30m buffer\n        }\n      } catch (error) {\n        // Fallback to distance-based radius\n      }\n      // Fallback radius based on distance from user\n      if (distanceFromUser <= 500) return 80; // Close stations need smaller radius\n      else if (distanceFromUser <= 1000) return 100;else if (distanceFromUser <= 2000) return 120;else if (distanceFromUser <= 5000) return 150;else return 200; // Distant stations need larger radius for reliability\n    }\n    /**\n     * Update active geofence regions in native system\n     */\n    updateActiveRegions(newRegions) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        const currentRegions = _this4.activeRegions.value;\n        // Find regions to remove\n        const currentIds = new Set(currentRegions.map(r => r.identifier));\n        const newIds = new Set(newRegions.map(r => r.identifier));\n        const toRemove = currentRegions.filter(r => !newIds.has(r.identifier));\n        const toAdd = newRegions.filter(r => !currentIds.has(r.identifier));\n        // Remove outdated regions\n        if (toRemove.length > 0) {\n          const identifiers = toRemove.map(r => r.identifier);\n          yield BackgroundGeofence.removeGeofences({\n            identifiers\n          });\n          console.log(`Removed ${toRemove.length} geofence regions`);\n        }\n        // Add new regions\n        if (toAdd.length > 0) {\n          const geofences = toAdd.map(r => ({\n            identifier: r.identifier,\n            latitude: r.latitude,\n            longitude: r.longitude,\n            radius: r.radius,\n            notifyOnEntry: r.notifyOnEntry,\n            notifyOnExit: r.notifyOnExit,\n            data: r.data\n          }));\n          yield BackgroundGeofence.addGeofences({\n            geofences\n          });\n          console.log(`Added ${toAdd.length} geofence regions`);\n        }\n        // Update stored regions\n        _this4.activeRegions.next(newRegions);\n        _this4.saveRegionsToStorage(newRegions);\n      })();\n    }\n    /**\n     * Get maximum geofence regions for current platform\n     */\n    getMaxRegions() {\n      // Detect platform - in real app you'd use Capacitor.getPlatform()\n      const platform = 'ios'; // or 'android' \n      return platform === 'ios' ? this.MAX_IOS_REGIONS : this.MAX_ANDROID_REGIONS;\n    }\n    /**\n     * Calculate distance between two coordinates\n     */\n    calculateDistance(lat1, lon1, lat2, lon2) {\n      const R = 6371e3; // Earth's radius in meters\n      const φ1 = lat1 * Math.PI / 180;\n      const φ2 = lat2 * Math.PI / 180;\n      const Δφ = (lat2 - lat1) * Math.PI / 180;\n      const Δλ = (lon2 - lon1) * Math.PI / 180;\n      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return R * c;\n    }\n    /**\n     * Save regions to local storage for persistence\n     */\n    saveRegionsToStorage(regions) {\n      const serializable = regions.map(region => ({\n        identifier: region.identifier,\n        latitude: region.latitude,\n        longitude: region.longitude,\n        radius: region.radius,\n        stationId: region.station.id,\n        priority: region.priority,\n        lastUpdated: region.lastUpdated.toISOString()\n      }));\n      localStorage.setItem('geofence_regions', JSON.stringify(serializable));\n    }\n    /**\n     * Load regions from local storage\n     */\n    loadStoredRegions() {\n      try {\n        const stored = localStorage.getItem('geofence_regions');\n        if (stored) {\n          const regions = JSON.parse(stored);\n          console.log(`Loaded ${regions.length} stored geofence regions`);\n        }\n      } catch (error) {\n        console.error('Failed to load stored regions:', error);\n      }\n    }\n    /**\n     * Update statistics\n     */\n    updateStats(updates) {\n      const current = this.stats.value;\n      this.stats.next({\n        ...current,\n        ...updates\n      });\n    }\n    // Observable getters\n    getCurrentLocation() {\n      return this.currentLocation.asObservable();\n    }\n    getActiveRegions() {\n      return this.activeRegions.asObservable();\n    }\n    getStats() {\n      return this.stats.asObservable();\n    }\n    // Public methods for manual control\n    forceOptimization() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        const location = _this5.currentLocation.value;\n        if (location) {\n          yield _this5.optimizeGeofenceRegions(location);\n        }\n      })();\n    }\n    clearAllRegions() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        const current = _this6.activeRegions.value;\n        if (current.length > 0) {\n          const identifiers = current.map(r => r.identifier);\n          yield BackgroundGeofence.removeGeofences({\n            identifiers\n          });\n          _this6.activeRegions.next([]);\n          localStorage.removeItem('geofence_regions');\n          _this6.updateStats({\n            activeRegions: 0,\n            lastOptimization: new Date()\n          });\n        }\n      })();\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GeofenceManagerService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GeofenceManagerService)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GeofenceManagerService,\n      factory: GeofenceManagerService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return GeofenceManagerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}