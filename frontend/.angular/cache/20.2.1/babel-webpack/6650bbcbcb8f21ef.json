{"ast":null,"code":"import _asyncToGenerator from \"/mnt/c/Users/aluta/station-tracker/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { BehaviorSubject, interval } from 'rxjs';\nimport { catchError, retry, timeout } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let CloudSyncService = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class CloudSyncService {\n    constructor(http) {\n      this.http = http;\n      this.API_BASE_URL = 'https://api.station-tracker.com'; // Replace with actual API\n      this.SYNC_INTERVAL = 30 * 1000; // 30 seconds\n      this.MAX_BATCH_SIZE = 50;\n      this.RETRY_ATTEMPTS = 3;\n      this.OFFLINE_STORAGE_KEY = 'pending_geofence_events';\n      this.syncStatus = new BehaviorSubject({\n        isOnline: navigator.onLine,\n        lastSync: null,\n        pendingEvents: 0,\n        syncErrors: 0,\n        totalEventsSynced: 0\n      });\n      this.pendingEvents = [];\n      this.deviceId = this.getOrCreateDeviceId();\n      this.loadPendingEvents();\n      this.setupNetworkListeners();\n      this.startPeriodicSync();\n    }\n    /**\n     * Add geofence event to sync queue\n     */\n    queueGeofenceEvent(event) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const cloudEvent = {\n          stationId: event.data?.stationId || 0,\n          stationName: event.data?.stationName || 'Unknown',\n          line: event.data?.line || 'Unknown',\n          eventType: event.action,\n          latitude: event.latitude,\n          longitude: event.longitude,\n          timestamp: new Date(event.timestamp).toISOString(),\n          deviceId: _this.deviceId,\n          appVersion: '1.0.0',\n          // Get from config\n          synced: false,\n          localTimestamp: new Date().toISOString()\n        };\n        _this.pendingEvents.push(cloudEvent);\n        _this.updateSyncStatus({\n          pendingEvents: _this.pendingEvents.length\n        });\n        // Save to offline storage\n        _this.savePendingEvents();\n        // Try immediate sync if online\n        if (navigator.onLine) {\n          _this.performSync();\n        }\n        console.log('Queued geofence event for sync:', cloudEvent);\n      })();\n    }\n    /**\n     * Perform sync with cloud API\n     */\n    performSync() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (_this2.pendingEvents.length === 0) return;\n        const currentStatus = _this2.syncStatus.value;\n        try {\n          // Take batch of events to sync\n          const batchSize = Math.min(_this2.MAX_BATCH_SIZE, _this2.pendingEvents.length);\n          const batch = _this2.pendingEvents.slice(0, batchSize);\n          console.log(`Syncing batch of ${batch.length} events...`);\n          const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${yield _this2.getAuthToken()}` // Implement auth\n          });\n          const response = yield _this2.http.post(`${_this2.API_BASE_URL}/geofence-events`, {\n            events: batch\n          }, {\n            headers\n          }).pipe(timeout(30000),\n          // 30 second timeout\n          retry(_this2.RETRY_ATTEMPTS), catchError(error => {\n            console.error('Sync failed:', error);\n            throw error;\n          })).toPromise();\n          if (response?.success) {\n            // Remove synced events from pending\n            _this2.pendingEvents.splice(0, batchSize);\n            _this2.updateSyncStatus({\n              lastSync: new Date(),\n              pendingEvents: _this2.pendingEvents.length,\n              totalEventsSynced: currentStatus.totalEventsSynced + batchSize,\n              syncErrors: Math.max(0, currentStatus.syncErrors - 1) // Reduce errors on success\n            });\n            _this2.savePendingEvents();\n            console.log(`Successfully synced ${batchSize} events`);\n            // Continue with next batch if more events pending\n            if (_this2.pendingEvents.length > 0) {\n              setTimeout(() => _this2.performSync(), 1000); // 1 second delay\n            }\n          } else {\n            throw new Error(response?.error || 'Sync failed');\n          }\n        } catch (error) {\n          console.error('Failed to sync geofence events:', error);\n          _this2.updateSyncStatus({\n            syncErrors: currentStatus.syncErrors + 1\n          });\n          // Implement exponential backoff for retries\n          const backoffDelay = Math.min(300000, Math.pow(2, currentStatus.syncErrors) * 1000); // Max 5 minutes\n          setTimeout(() => {\n            if (navigator.onLine) {\n              _this2.performSync();\n            }\n          }, backoffDelay);\n        }\n      })();\n    }\n    /**\n     * Get authentication token (implement based on your auth system)\n     */\n    getAuthToken() {\n      return _asyncToGenerator(function* () {\n        // Implement your authentication logic here\n        // This might involve:\n        // - Getting stored token from secure storage\n        // - Refreshing token if expired\n        // - Anonymous authentication for device\n        return localStorage.getItem('auth_token') || 'anonymous';\n      })();\n    }\n    /**\n     * Setup network connectivity listeners\n     */\n    setupNetworkListeners() {\n      window.addEventListener('online', () => {\n        console.log('Network back online, resuming sync...');\n        this.updateSyncStatus({\n          isOnline: true\n        });\n        this.performSync();\n      });\n      window.addEventListener('offline', () => {\n        console.log('Network offline, queueing events...');\n        this.updateSyncStatus({\n          isOnline: false\n        });\n      });\n    }\n    /**\n     * Start periodic sync process\n     */\n    startPeriodicSync() {\n      this.syncSubscription = interval(this.SYNC_INTERVAL).subscribe(() => {\n        if (navigator.onLine && this.pendingEvents.length > 0) {\n          this.performSync();\n        }\n      });\n    }\n    /**\n     * Get or create unique device ID\n     */\n    getOrCreateDeviceId() {\n      let deviceId = localStorage.getItem('device_id');\n      if (!deviceId) {\n        deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n        localStorage.setItem('device_id', deviceId);\n      }\n      return deviceId;\n    }\n    /**\n     * Save pending events to offline storage\n     */\n    savePendingEvents() {\n      try {\n        localStorage.setItem(this.OFFLINE_STORAGE_KEY, JSON.stringify(this.pendingEvents));\n      } catch (error) {\n        console.error('Failed to save pending events:', error);\n      }\n    }\n    /**\n     * Load pending events from offline storage\n     */\n    loadPendingEvents() {\n      try {\n        const stored = localStorage.getItem(this.OFFLINE_STORAGE_KEY);\n        if (stored) {\n          this.pendingEvents = JSON.parse(stored);\n          this.updateSyncStatus({\n            pendingEvents: this.pendingEvents.length\n          });\n          console.log(`Loaded ${this.pendingEvents.length} pending events from storage`);\n        }\n      } catch (error) {\n        console.error('Failed to load pending events:', error);\n        this.pendingEvents = [];\n      }\n    }\n    /**\n     * Update sync status\n     */\n    updateSyncStatus(updates) {\n      const current = this.syncStatus.value;\n      this.syncStatus.next({\n        ...current,\n        ...updates\n      });\n    }\n    /**\n     * Manual sync trigger\n     */\n    forcSync() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (!navigator.onLine) {\n          throw new Error('Device is offline');\n        }\n        yield _this3.performSync();\n      })();\n    }\n    /**\n     * Get sync statistics\n     */\n    getSyncStats() {\n      return this.syncStatus.value;\n    }\n    /**\n     * Clear all pending events (use with caution)\n     */\n    clearPendingEvents() {\n      this.pendingEvents = [];\n      this.updateSyncStatus({\n        pendingEvents: 0\n      });\n      localStorage.removeItem(this.OFFLINE_STORAGE_KEY);\n      console.log('Cleared all pending events');\n    }\n    /**\n     * Send station visit data to server\n     */\n    syncStationVisit(visitData) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const headers = new HttpHeaders({\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${yield _this4.getAuthToken()}`\n          });\n          const response = yield _this4.http.post(`${_this4.API_BASE_URL}/station-visits`, {\n            ...visitData,\n            deviceId: _this4.deviceId\n          }, {\n            headers\n          }).pipe(timeout(15000), retry(2)).toPromise();\n          if (!response?.success) {\n            throw new Error(response?.error || 'Failed to sync station visit');\n          }\n          console.log('Station visit synced successfully');\n        } catch (error) {\n          console.error('Failed to sync station visit:', error);\n          // Could queue for later retry if needed\n        }\n      })();\n    }\n    /**\n     * Fetch server configuration updates\n     */\n    fetchServerConfig() {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const headers = new HttpHeaders({\n            'Authorization': `Bearer ${yield _this5.getAuthToken()}`\n          });\n          const response = yield _this5.http.get(`${_this5.API_BASE_URL}/config`, {\n            headers\n          }).pipe(timeout(10000), retry(1)).toPromise();\n          if (response?.success && response.data) {\n            console.log('Server config updated:', response.data);\n            return response.data;\n          }\n        } catch (error) {\n          console.error('Failed to fetch server config:', error);\n        }\n        return null;\n      })();\n    }\n    /**\n     * Report app analytics\n     */\n    reportAnalytics(eventName, data) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const analyticsData = {\n            event: eventName,\n            data,\n            deviceId: _this6.deviceId,\n            timestamp: new Date().toISOString(),\n            appVersion: '1.0.0'\n          };\n          // Fire and forget - don't block user experience\n          _this6.http.post(`${_this6.API_BASE_URL}/analytics`, analyticsData, {\n            headers: new HttpHeaders({\n              'Content-Type': 'application/json'\n            })\n          }).subscribe({\n            next: () => console.log('Analytics reported'),\n            error: error => console.warn('Analytics failed:', error)\n          });\n        } catch (error) {\n          console.warn('Analytics error:', error);\n        }\n      })();\n    }\n    // Observable getters\n    getSyncStatus() {\n      return this.syncStatus.asObservable();\n    }\n    // Cleanup\n    destroy() {\n      if (this.syncSubscription) {\n        this.syncSubscription.unsubscribe();\n      }\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function CloudSyncService_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CloudSyncService)(i0.ɵɵinject(i1.HttpClient));\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: CloudSyncService,\n      factory: CloudSyncService.ɵfac,\n      providedIn: 'root'\n    }));\n  }\n  _staticBlock();\n  return CloudSyncService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}